/* soapC.c
   Generated by gSOAP 2.7.10 from imRoot.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.10 2013-04-08 09:10:09 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns3__updateServerInfo:
		return soap_in_ns3__updateServerInfo(soap, NULL, NULL, "ns3:updateServerInfo");
	case SOAP_TYPE_ns3__updateServerInfoResponse:
		return soap_in_ns3__updateServerInfoResponse(soap, NULL, NULL, "ns3:updateServerInfoResponse");
	case SOAP_TYPE_ns3__updateSysConf:
		return soap_in_ns3__updateSysConf(soap, NULL, NULL, "ns3:updateSysConf");
	case SOAP_TYPE_ns3__updateSysConfResponse:
		return soap_in_ns3__updateSysConfResponse(soap, NULL, NULL, "ns3:updateSysConfResponse");
	case SOAP_TYPE_ns3__setMileage:
		return soap_in_ns3__setMileage(soap, NULL, NULL, "ns3:setMileage");
	case SOAP_TYPE_ns3__setMileageResponse:
		return soap_in_ns3__setMileageResponse(soap, NULL, NULL, "ns3:setMileageResponse");
	case SOAP_TYPE_ns3__setGPSFrequency:
		return soap_in_ns3__setGPSFrequency(soap, NULL, NULL, "ns3:setGPSFrequency");
	case SOAP_TYPE_ns3__setGPSFrequencyResponse:
		return soap_in_ns3__setGPSFrequencyResponse(soap, NULL, NULL, "ns3:setGPSFrequencyResponse");
	case SOAP_TYPE_ns3__sendMessage:
		return soap_in_ns3__sendMessage(soap, NULL, NULL, "ns3:sendMessage");
	case SOAP_TYPE_ns3__sendMessageResponse:
		return soap_in_ns3__sendMessageResponse(soap, NULL, NULL, "ns3:sendMessageResponse");
	case SOAP_TYPE_ns3__queryVersion:
		return soap_in_ns3__queryVersion(soap, NULL, NULL, "ns3:queryVersion");
	case SOAP_TYPE_ns3__queryVersionResponse:
		return soap_in_ns3__queryVersionResponse(soap, NULL, NULL, "ns3:queryVersionResponse");
	case SOAP_TYPE_ns3__takePhoto:
		return soap_in_ns3__takePhoto(soap, NULL, NULL, "ns3:takePhoto");
	case SOAP_TYPE_ns3__takePhotoResponse:
		return soap_in_ns3__takePhotoResponse(soap, NULL, NULL, "ns3:takePhotoResponse");
	case SOAP_TYPE_ns2__UpdateServerInfoResp:
		return soap_in_ns2__UpdateServerInfoResp(soap, NULL, NULL, "ns2:UpdateServerInfoResp");
	case SOAP_TYPE_ns2__UpdateServerInfoReq:
		return soap_in_ns2__UpdateServerInfoReq(soap, NULL, NULL, "ns2:UpdateServerInfoReq");
	case SOAP_TYPE_ns2__UpdateSysConfResp:
		return soap_in_ns2__UpdateSysConfResp(soap, NULL, NULL, "ns2:UpdateSysConfResp");
	case SOAP_TYPE_ns2__UpdateSysConfReq:
		return soap_in_ns2__UpdateSysConfReq(soap, NULL, NULL, "ns2:UpdateSysConfReq");
	case SOAP_TYPE_ns2__SetMileageResp:
		return soap_in_ns2__SetMileageResp(soap, NULL, NULL, "ns2:SetMileageResp");
	case SOAP_TYPE_ns2__SetMileageReq:
		return soap_in_ns2__SetMileageReq(soap, NULL, NULL, "ns2:SetMileageReq");
	case SOAP_TYPE_ns2__SetGPSFrequencyResp:
		return soap_in_ns2__SetGPSFrequencyResp(soap, NULL, NULL, "ns2:SetGPSFrequencyResp");
	case SOAP_TYPE_ns2__SetGPSFrequencyReq:
		return soap_in_ns2__SetGPSFrequencyReq(soap, NULL, NULL, "ns2:SetGPSFrequencyReq");
	case SOAP_TYPE_ns2__SendMsgResp:
		return soap_in_ns2__SendMsgResp(soap, NULL, NULL, "ns2:SendMsgResp");
	case SOAP_TYPE_ns2__SendMsgReq:
		return soap_in_ns2__SendMsgReq(soap, NULL, NULL, "ns2:SendMsgReq");
	case SOAP_TYPE_ns2__QueryVerResp:
		return soap_in_ns2__QueryVerResp(soap, NULL, NULL, "ns2:QueryVerResp");
	case SOAP_TYPE_ns2__QueryVerReq:
		return soap_in_ns2__QueryVerReq(soap, NULL, NULL, "ns2:QueryVerReq");
	case SOAP_TYPE_ns2__TakePhotoResp:
		return soap_in_ns2__TakePhotoResp(soap, NULL, NULL, "ns2:TakePhotoResp");
	case SOAP_TYPE_ns2__TakePhotoReq:
		return soap_in_ns2__TakePhotoReq(soap, NULL, NULL, "ns2:TakePhotoReq");
	case SOAP_TYPE_PointerTons3__updateServerInfoResponse:
		return soap_in_PointerTons3__updateServerInfoResponse(soap, NULL, NULL, "ns3:updateServerInfoResponse");
	case SOAP_TYPE_PointerTons2__UpdateServerInfoReq:
		return soap_in_PointerTons2__UpdateServerInfoReq(soap, NULL, NULL, "ns2:UpdateServerInfoReq");
	case SOAP_TYPE_PointerTons2__UpdateServerInfoResp:
		return soap_in_PointerTons2__UpdateServerInfoResp(soap, NULL, NULL, "ns2:UpdateServerInfoResp");
	case SOAP_TYPE_PointerTons3__updateSysConfResponse:
		return soap_in_PointerTons3__updateSysConfResponse(soap, NULL, NULL, "ns3:updateSysConfResponse");
	case SOAP_TYPE_PointerTons2__UpdateSysConfReq:
		return soap_in_PointerTons2__UpdateSysConfReq(soap, NULL, NULL, "ns2:UpdateSysConfReq");
	case SOAP_TYPE_PointerTons2__UpdateSysConfResp:
		return soap_in_PointerTons2__UpdateSysConfResp(soap, NULL, NULL, "ns2:UpdateSysConfResp");
	case SOAP_TYPE_PointerTons3__setMileageResponse:
		return soap_in_PointerTons3__setMileageResponse(soap, NULL, NULL, "ns3:setMileageResponse");
	case SOAP_TYPE_PointerTons2__SetMileageReq:
		return soap_in_PointerTons2__SetMileageReq(soap, NULL, NULL, "ns2:SetMileageReq");
	case SOAP_TYPE_PointerTons2__SetMileageResp:
		return soap_in_PointerTons2__SetMileageResp(soap, NULL, NULL, "ns2:SetMileageResp");
	case SOAP_TYPE_PointerTons3__setGPSFrequencyResponse:
		return soap_in_PointerTons3__setGPSFrequencyResponse(soap, NULL, NULL, "ns3:setGPSFrequencyResponse");
	case SOAP_TYPE_PointerTons2__SetGPSFrequencyReq:
		return soap_in_PointerTons2__SetGPSFrequencyReq(soap, NULL, NULL, "ns2:SetGPSFrequencyReq");
	case SOAP_TYPE_PointerTons2__SetGPSFrequencyResp:
		return soap_in_PointerTons2__SetGPSFrequencyResp(soap, NULL, NULL, "ns2:SetGPSFrequencyResp");
	case SOAP_TYPE_PointerTons3__sendMessageResponse:
		return soap_in_PointerTons3__sendMessageResponse(soap, NULL, NULL, "ns3:sendMessageResponse");
	case SOAP_TYPE_PointerTons2__SendMsgReq:
		return soap_in_PointerTons2__SendMsgReq(soap, NULL, NULL, "ns2:SendMsgReq");
	case SOAP_TYPE_PointerTons2__SendMsgResp:
		return soap_in_PointerTons2__SendMsgResp(soap, NULL, NULL, "ns2:SendMsgResp");
	case SOAP_TYPE_PointerTons3__queryVersionResponse:
		return soap_in_PointerTons3__queryVersionResponse(soap, NULL, NULL, "ns3:queryVersionResponse");
	case SOAP_TYPE_PointerTons2__QueryVerReq:
		return soap_in_PointerTons2__QueryVerReq(soap, NULL, NULL, "ns2:QueryVerReq");
	case SOAP_TYPE_PointerTons2__QueryVerResp:
		return soap_in_PointerTons2__QueryVerResp(soap, NULL, NULL, "ns2:QueryVerResp");
	case SOAP_TYPE_PointerTons3__takePhotoResponse:
		return soap_in_PointerTons3__takePhotoResponse(soap, NULL, NULL, "ns3:takePhotoResponse");
	case SOAP_TYPE_PointerTons2__TakePhotoReq:
		return soap_in_PointerTons2__TakePhotoReq(soap, NULL, NULL, "ns2:TakePhotoReq");
	case SOAP_TYPE_PointerTons2__TakePhotoResp:
		return soap_in_PointerTons2__TakePhotoResp(soap, NULL, NULL, "ns2:TakePhotoResp");
	case SOAP_TYPE_PointerTo_ns1__sayHelloResponse:
		return soap_in_PointerTo_ns1__sayHelloResponse(soap, NULL, NULL, "ns1:sayHelloResponse");
	case SOAP_TYPE_PointerTo_ns1__sayHello:
		return soap_in_PointerTo_ns1__sayHello(soap, NULL, NULL, "ns1:sayHello");
	case SOAP_TYPE_PointerTo_ns1__OperationCenterResponse:
		return soap_in_PointerTo_ns1__OperationCenterResponse(soap, NULL, NULL, "ns1:OperationCenterResponse");
	case SOAP_TYPE_PointerTo_ns1__OperationCenter:
		return soap_in_PointerTo_ns1__OperationCenter(soap, NULL, NULL, "ns1:OperationCenter");
	case SOAP_TYPE_PointerTo_ns1__OperationSmsResponse:
		return soap_in_PointerTo_ns1__OperationSmsResponse(soap, NULL, NULL, "ns1:OperationSmsResponse");
	case SOAP_TYPE_PointerTo_ns1__OperationSms:
		return soap_in_PointerTo_ns1__OperationSms(soap, NULL, NULL, "ns1:OperationSms");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:updateServerInfo"))
		{	*type = SOAP_TYPE_ns3__updateServerInfo;
			return soap_in_ns3__updateServerInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:updateServerInfoResponse"))
		{	*type = SOAP_TYPE_ns3__updateServerInfoResponse;
			return soap_in_ns3__updateServerInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:updateSysConf"))
		{	*type = SOAP_TYPE_ns3__updateSysConf;
			return soap_in_ns3__updateSysConf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:updateSysConfResponse"))
		{	*type = SOAP_TYPE_ns3__updateSysConfResponse;
			return soap_in_ns3__updateSysConfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setMileage"))
		{	*type = SOAP_TYPE_ns3__setMileage;
			return soap_in_ns3__setMileage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setMileageResponse"))
		{	*type = SOAP_TYPE_ns3__setMileageResponse;
			return soap_in_ns3__setMileageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setGPSFrequency"))
		{	*type = SOAP_TYPE_ns3__setGPSFrequency;
			return soap_in_ns3__setGPSFrequency(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setGPSFrequencyResponse"))
		{	*type = SOAP_TYPE_ns3__setGPSFrequencyResponse;
			return soap_in_ns3__setGPSFrequencyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:sendMessage"))
		{	*type = SOAP_TYPE_ns3__sendMessage;
			return soap_in_ns3__sendMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:sendMessageResponse"))
		{	*type = SOAP_TYPE_ns3__sendMessageResponse;
			return soap_in_ns3__sendMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:queryVersion"))
		{	*type = SOAP_TYPE_ns3__queryVersion;
			return soap_in_ns3__queryVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:queryVersionResponse"))
		{	*type = SOAP_TYPE_ns3__queryVersionResponse;
			return soap_in_ns3__queryVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:takePhoto"))
		{	*type = SOAP_TYPE_ns3__takePhoto;
			return soap_in_ns3__takePhoto(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:takePhotoResponse"))
		{	*type = SOAP_TYPE_ns3__takePhotoResponse;
			return soap_in_ns3__takePhotoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UpdateServerInfoResp"))
		{	*type = SOAP_TYPE_ns2__UpdateServerInfoResp;
			return soap_in_ns2__UpdateServerInfoResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UpdateServerInfoReq"))
		{	*type = SOAP_TYPE_ns2__UpdateServerInfoReq;
			return soap_in_ns2__UpdateServerInfoReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UpdateSysConfResp"))
		{	*type = SOAP_TYPE_ns2__UpdateSysConfResp;
			return soap_in_ns2__UpdateSysConfResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UpdateSysConfReq"))
		{	*type = SOAP_TYPE_ns2__UpdateSysConfReq;
			return soap_in_ns2__UpdateSysConfReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SetMileageResp"))
		{	*type = SOAP_TYPE_ns2__SetMileageResp;
			return soap_in_ns2__SetMileageResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SetMileageReq"))
		{	*type = SOAP_TYPE_ns2__SetMileageReq;
			return soap_in_ns2__SetMileageReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SetGPSFrequencyResp"))
		{	*type = SOAP_TYPE_ns2__SetGPSFrequencyResp;
			return soap_in_ns2__SetGPSFrequencyResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SetGPSFrequencyReq"))
		{	*type = SOAP_TYPE_ns2__SetGPSFrequencyReq;
			return soap_in_ns2__SetGPSFrequencyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SendMsgResp"))
		{	*type = SOAP_TYPE_ns2__SendMsgResp;
			return soap_in_ns2__SendMsgResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SendMsgReq"))
		{	*type = SOAP_TYPE_ns2__SendMsgReq;
			return soap_in_ns2__SendMsgReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:QueryVerResp"))
		{	*type = SOAP_TYPE_ns2__QueryVerResp;
			return soap_in_ns2__QueryVerResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:QueryVerReq"))
		{	*type = SOAP_TYPE_ns2__QueryVerReq;
			return soap_in_ns2__QueryVerReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TakePhotoResp"))
		{	*type = SOAP_TYPE_ns2__TakePhotoResp;
			return soap_in_ns2__TakePhotoResp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TakePhotoReq"))
		{	*type = SOAP_TYPE_ns2__TakePhotoReq;
			return soap_in_ns2__TakePhotoReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:sayHelloResponse"))
		{	*type = SOAP_TYPE__ns1__sayHelloResponse;
			return soap_in__ns1__sayHelloResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sayHello"))
		{	*type = SOAP_TYPE__ns1__sayHello;
			return soap_in__ns1__sayHello(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OperationCenterResponse"))
		{	*type = SOAP_TYPE__ns1__OperationCenterResponse;
			return soap_in__ns1__OperationCenterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OperationCenter"))
		{	*type = SOAP_TYPE__ns1__OperationCenter;
			return soap_in__ns1__OperationCenter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OperationSmsResponse"))
		{	*type = SOAP_TYPE__ns1__OperationSmsResponse;
			return soap_in__ns1__OperationSmsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OperationSms"))
		{	*type = SOAP_TYPE__ns1__OperationSms;
			return soap_in__ns1__OperationSms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns3__updateServerInfo:
		return soap_out_ns3__updateServerInfo(soap, tag, id, (const struct ns3__updateServerInfo *)ptr, "ns3:updateServerInfo");
	case SOAP_TYPE_ns3__updateServerInfoResponse:
		return soap_out_ns3__updateServerInfoResponse(soap, tag, id, (const struct ns3__updateServerInfoResponse *)ptr, "ns3:updateServerInfoResponse");
	case SOAP_TYPE_ns3__updateSysConf:
		return soap_out_ns3__updateSysConf(soap, tag, id, (const struct ns3__updateSysConf *)ptr, "ns3:updateSysConf");
	case SOAP_TYPE_ns3__updateSysConfResponse:
		return soap_out_ns3__updateSysConfResponse(soap, tag, id, (const struct ns3__updateSysConfResponse *)ptr, "ns3:updateSysConfResponse");
	case SOAP_TYPE_ns3__setMileage:
		return soap_out_ns3__setMileage(soap, tag, id, (const struct ns3__setMileage *)ptr, "ns3:setMileage");
	case SOAP_TYPE_ns3__setMileageResponse:
		return soap_out_ns3__setMileageResponse(soap, tag, id, (const struct ns3__setMileageResponse *)ptr, "ns3:setMileageResponse");
	case SOAP_TYPE_ns3__setGPSFrequency:
		return soap_out_ns3__setGPSFrequency(soap, tag, id, (const struct ns3__setGPSFrequency *)ptr, "ns3:setGPSFrequency");
	case SOAP_TYPE_ns3__setGPSFrequencyResponse:
		return soap_out_ns3__setGPSFrequencyResponse(soap, tag, id, (const struct ns3__setGPSFrequencyResponse *)ptr, "ns3:setGPSFrequencyResponse");
	case SOAP_TYPE_ns3__sendMessage:
		return soap_out_ns3__sendMessage(soap, tag, id, (const struct ns3__sendMessage *)ptr, "ns3:sendMessage");
	case SOAP_TYPE_ns3__sendMessageResponse:
		return soap_out_ns3__sendMessageResponse(soap, tag, id, (const struct ns3__sendMessageResponse *)ptr, "ns3:sendMessageResponse");
	case SOAP_TYPE_ns3__queryVersion:
		return soap_out_ns3__queryVersion(soap, tag, id, (const struct ns3__queryVersion *)ptr, "ns3:queryVersion");
	case SOAP_TYPE_ns3__queryVersionResponse:
		return soap_out_ns3__queryVersionResponse(soap, tag, id, (const struct ns3__queryVersionResponse *)ptr, "ns3:queryVersionResponse");
	case SOAP_TYPE_ns3__takePhoto:
		return soap_out_ns3__takePhoto(soap, tag, id, (const struct ns3__takePhoto *)ptr, "ns3:takePhoto");
	case SOAP_TYPE_ns3__takePhotoResponse:
		return soap_out_ns3__takePhotoResponse(soap, tag, id, (const struct ns3__takePhotoResponse *)ptr, "ns3:takePhotoResponse");
	case SOAP_TYPE_ns2__UpdateServerInfoResp:
		return soap_out_ns2__UpdateServerInfoResp(soap, tag, id, (const struct ns2__UpdateServerInfoResp *)ptr, "ns2:UpdateServerInfoResp");
	case SOAP_TYPE_ns2__UpdateServerInfoReq:
		return soap_out_ns2__UpdateServerInfoReq(soap, tag, id, (const struct ns2__UpdateServerInfoReq *)ptr, "ns2:UpdateServerInfoReq");
	case SOAP_TYPE_ns2__UpdateSysConfResp:
		return soap_out_ns2__UpdateSysConfResp(soap, tag, id, (const struct ns2__UpdateSysConfResp *)ptr, "ns2:UpdateSysConfResp");
	case SOAP_TYPE_ns2__UpdateSysConfReq:
		return soap_out_ns2__UpdateSysConfReq(soap, tag, id, (const struct ns2__UpdateSysConfReq *)ptr, "ns2:UpdateSysConfReq");
	case SOAP_TYPE_ns2__SetMileageResp:
		return soap_out_ns2__SetMileageResp(soap, tag, id, (const struct ns2__SetMileageResp *)ptr, "ns2:SetMileageResp");
	case SOAP_TYPE_ns2__SetMileageReq:
		return soap_out_ns2__SetMileageReq(soap, tag, id, (const struct ns2__SetMileageReq *)ptr, "ns2:SetMileageReq");
	case SOAP_TYPE_ns2__SetGPSFrequencyResp:
		return soap_out_ns2__SetGPSFrequencyResp(soap, tag, id, (const struct ns2__SetGPSFrequencyResp *)ptr, "ns2:SetGPSFrequencyResp");
	case SOAP_TYPE_ns2__SetGPSFrequencyReq:
		return soap_out_ns2__SetGPSFrequencyReq(soap, tag, id, (const struct ns2__SetGPSFrequencyReq *)ptr, "ns2:SetGPSFrequencyReq");
	case SOAP_TYPE_ns2__SendMsgResp:
		return soap_out_ns2__SendMsgResp(soap, tag, id, (const struct ns2__SendMsgResp *)ptr, "ns2:SendMsgResp");
	case SOAP_TYPE_ns2__SendMsgReq:
		return soap_out_ns2__SendMsgReq(soap, tag, id, (const struct ns2__SendMsgReq *)ptr, "ns2:SendMsgReq");
	case SOAP_TYPE_ns2__QueryVerResp:
		return soap_out_ns2__QueryVerResp(soap, tag, id, (const struct ns2__QueryVerResp *)ptr, "ns2:QueryVerResp");
	case SOAP_TYPE_ns2__QueryVerReq:
		return soap_out_ns2__QueryVerReq(soap, tag, id, (const struct ns2__QueryVerReq *)ptr, "ns2:QueryVerReq");
	case SOAP_TYPE_ns2__TakePhotoResp:
		return soap_out_ns2__TakePhotoResp(soap, tag, id, (const struct ns2__TakePhotoResp *)ptr, "ns2:TakePhotoResp");
	case SOAP_TYPE_ns2__TakePhotoReq:
		return soap_out_ns2__TakePhotoReq(soap, tag, id, (const struct ns2__TakePhotoReq *)ptr, "ns2:TakePhotoReq");
	case SOAP_TYPE__ns1__sayHelloResponse:
		return soap_out__ns1__sayHelloResponse(soap, "ns1:sayHelloResponse", id, (const struct _ns1__sayHelloResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__sayHello:
		return soap_out__ns1__sayHello(soap, "ns1:sayHello", id, (const struct _ns1__sayHello *)ptr, NULL);
	case SOAP_TYPE__ns1__OperationCenterResponse:
		return soap_out__ns1__OperationCenterResponse(soap, "ns1:OperationCenterResponse", id, (const struct _ns1__OperationCenterResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__OperationCenter:
		return soap_out__ns1__OperationCenter(soap, "ns1:OperationCenter", id, (const struct _ns1__OperationCenter *)ptr, NULL);
	case SOAP_TYPE__ns1__OperationSmsResponse:
		return soap_out__ns1__OperationSmsResponse(soap, "ns1:OperationSmsResponse", id, (const struct _ns1__OperationSmsResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__OperationSms:
		return soap_out__ns1__OperationSms(soap, "ns1:OperationSms", id, (const struct _ns1__OperationSms *)ptr, NULL);
	case SOAP_TYPE_PointerTons3__updateServerInfoResponse:
		return soap_out_PointerTons3__updateServerInfoResponse(soap, tag, id, (struct ns3__updateServerInfoResponse *const*)ptr, "ns3:updateServerInfoResponse");
	case SOAP_TYPE_PointerTons2__UpdateServerInfoReq:
		return soap_out_PointerTons2__UpdateServerInfoReq(soap, tag, id, (struct ns2__UpdateServerInfoReq *const*)ptr, "ns2:UpdateServerInfoReq");
	case SOAP_TYPE_PointerTons2__UpdateServerInfoResp:
		return soap_out_PointerTons2__UpdateServerInfoResp(soap, tag, id, (struct ns2__UpdateServerInfoResp *const*)ptr, "ns2:UpdateServerInfoResp");
	case SOAP_TYPE_PointerTons3__updateSysConfResponse:
		return soap_out_PointerTons3__updateSysConfResponse(soap, tag, id, (struct ns3__updateSysConfResponse *const*)ptr, "ns3:updateSysConfResponse");
	case SOAP_TYPE_PointerTons2__UpdateSysConfReq:
		return soap_out_PointerTons2__UpdateSysConfReq(soap, tag, id, (struct ns2__UpdateSysConfReq *const*)ptr, "ns2:UpdateSysConfReq");
	case SOAP_TYPE_PointerTons2__UpdateSysConfResp:
		return soap_out_PointerTons2__UpdateSysConfResp(soap, tag, id, (struct ns2__UpdateSysConfResp *const*)ptr, "ns2:UpdateSysConfResp");
	case SOAP_TYPE_PointerTons3__setMileageResponse:
		return soap_out_PointerTons3__setMileageResponse(soap, tag, id, (struct ns3__setMileageResponse *const*)ptr, "ns3:setMileageResponse");
	case SOAP_TYPE_PointerTons2__SetMileageReq:
		return soap_out_PointerTons2__SetMileageReq(soap, tag, id, (struct ns2__SetMileageReq *const*)ptr, "ns2:SetMileageReq");
	case SOAP_TYPE_PointerTons2__SetMileageResp:
		return soap_out_PointerTons2__SetMileageResp(soap, tag, id, (struct ns2__SetMileageResp *const*)ptr, "ns2:SetMileageResp");
	case SOAP_TYPE_PointerTons3__setGPSFrequencyResponse:
		return soap_out_PointerTons3__setGPSFrequencyResponse(soap, tag, id, (struct ns3__setGPSFrequencyResponse *const*)ptr, "ns3:setGPSFrequencyResponse");
	case SOAP_TYPE_PointerTons2__SetGPSFrequencyReq:
		return soap_out_PointerTons2__SetGPSFrequencyReq(soap, tag, id, (struct ns2__SetGPSFrequencyReq *const*)ptr, "ns2:SetGPSFrequencyReq");
	case SOAP_TYPE_PointerTons2__SetGPSFrequencyResp:
		return soap_out_PointerTons2__SetGPSFrequencyResp(soap, tag, id, (struct ns2__SetGPSFrequencyResp *const*)ptr, "ns2:SetGPSFrequencyResp");
	case SOAP_TYPE_PointerTons3__sendMessageResponse:
		return soap_out_PointerTons3__sendMessageResponse(soap, tag, id, (struct ns3__sendMessageResponse *const*)ptr, "ns3:sendMessageResponse");
	case SOAP_TYPE_PointerTons2__SendMsgReq:
		return soap_out_PointerTons2__SendMsgReq(soap, tag, id, (struct ns2__SendMsgReq *const*)ptr, "ns2:SendMsgReq");
	case SOAP_TYPE_PointerTons2__SendMsgResp:
		return soap_out_PointerTons2__SendMsgResp(soap, tag, id, (struct ns2__SendMsgResp *const*)ptr, "ns2:SendMsgResp");
	case SOAP_TYPE_PointerTons3__queryVersionResponse:
		return soap_out_PointerTons3__queryVersionResponse(soap, tag, id, (struct ns3__queryVersionResponse *const*)ptr, "ns3:queryVersionResponse");
	case SOAP_TYPE_PointerTons2__QueryVerReq:
		return soap_out_PointerTons2__QueryVerReq(soap, tag, id, (struct ns2__QueryVerReq *const*)ptr, "ns2:QueryVerReq");
	case SOAP_TYPE_PointerTons2__QueryVerResp:
		return soap_out_PointerTons2__QueryVerResp(soap, tag, id, (struct ns2__QueryVerResp *const*)ptr, "ns2:QueryVerResp");
	case SOAP_TYPE_PointerTons3__takePhotoResponse:
		return soap_out_PointerTons3__takePhotoResponse(soap, tag, id, (struct ns3__takePhotoResponse *const*)ptr, "ns3:takePhotoResponse");
	case SOAP_TYPE_PointerTons2__TakePhotoReq:
		return soap_out_PointerTons2__TakePhotoReq(soap, tag, id, (struct ns2__TakePhotoReq *const*)ptr, "ns2:TakePhotoReq");
	case SOAP_TYPE_PointerTons2__TakePhotoResp:
		return soap_out_PointerTons2__TakePhotoResp(soap, tag, id, (struct ns2__TakePhotoResp *const*)ptr, "ns2:TakePhotoResp");
	case SOAP_TYPE_PointerTo_ns1__sayHelloResponse:
		return soap_out_PointerTo_ns1__sayHelloResponse(soap, tag, id, (struct _ns1__sayHelloResponse *const*)ptr, "ns1:sayHelloResponse");
	case SOAP_TYPE_PointerTo_ns1__sayHello:
		return soap_out_PointerTo_ns1__sayHello(soap, tag, id, (struct _ns1__sayHello *const*)ptr, "ns1:sayHello");
	case SOAP_TYPE_PointerTo_ns1__OperationCenterResponse:
		return soap_out_PointerTo_ns1__OperationCenterResponse(soap, tag, id, (struct _ns1__OperationCenterResponse *const*)ptr, "ns1:OperationCenterResponse");
	case SOAP_TYPE_PointerTo_ns1__OperationCenter:
		return soap_out_PointerTo_ns1__OperationCenter(soap, tag, id, (struct _ns1__OperationCenter *const*)ptr, "ns1:OperationCenter");
	case SOAP_TYPE_PointerTo_ns1__OperationSmsResponse:
		return soap_out_PointerTo_ns1__OperationSmsResponse(soap, tag, id, (struct _ns1__OperationSmsResponse *const*)ptr, "ns1:OperationSmsResponse");
	case SOAP_TYPE_PointerTo_ns1__OperationSms:
		return soap_out_PointerTo_ns1__OperationSms(soap, tag, id, (struct _ns1__OperationSms *const*)ptr, "ns1:OperationSms");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns3__updateServerInfo:
		soap_serialize_ns3__updateServerInfo(soap, (const struct ns3__updateServerInfo *)ptr);
		break;
	case SOAP_TYPE_ns3__updateServerInfoResponse:
		soap_serialize_ns3__updateServerInfoResponse(soap, (const struct ns3__updateServerInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns3__updateSysConf:
		soap_serialize_ns3__updateSysConf(soap, (const struct ns3__updateSysConf *)ptr);
		break;
	case SOAP_TYPE_ns3__updateSysConfResponse:
		soap_serialize_ns3__updateSysConfResponse(soap, (const struct ns3__updateSysConfResponse *)ptr);
		break;
	case SOAP_TYPE_ns3__setMileage:
		soap_serialize_ns3__setMileage(soap, (const struct ns3__setMileage *)ptr);
		break;
	case SOAP_TYPE_ns3__setMileageResponse:
		soap_serialize_ns3__setMileageResponse(soap, (const struct ns3__setMileageResponse *)ptr);
		break;
	case SOAP_TYPE_ns3__setGPSFrequency:
		soap_serialize_ns3__setGPSFrequency(soap, (const struct ns3__setGPSFrequency *)ptr);
		break;
	case SOAP_TYPE_ns3__setGPSFrequencyResponse:
		soap_serialize_ns3__setGPSFrequencyResponse(soap, (const struct ns3__setGPSFrequencyResponse *)ptr);
		break;
	case SOAP_TYPE_ns3__sendMessage:
		soap_serialize_ns3__sendMessage(soap, (const struct ns3__sendMessage *)ptr);
		break;
	case SOAP_TYPE_ns3__sendMessageResponse:
		soap_serialize_ns3__sendMessageResponse(soap, (const struct ns3__sendMessageResponse *)ptr);
		break;
	case SOAP_TYPE_ns3__queryVersion:
		soap_serialize_ns3__queryVersion(soap, (const struct ns3__queryVersion *)ptr);
		break;
	case SOAP_TYPE_ns3__queryVersionResponse:
		soap_serialize_ns3__queryVersionResponse(soap, (const struct ns3__queryVersionResponse *)ptr);
		break;
	case SOAP_TYPE_ns3__takePhoto:
		soap_serialize_ns3__takePhoto(soap, (const struct ns3__takePhoto *)ptr);
		break;
	case SOAP_TYPE_ns3__takePhotoResponse:
		soap_serialize_ns3__takePhotoResponse(soap, (const struct ns3__takePhotoResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__sayHello:
		soap_serialize___ns1__sayHello(soap, (const struct __ns1__sayHello *)ptr);
		break;
	case SOAP_TYPE___ns1__OperationCenter:
		soap_serialize___ns1__OperationCenter(soap, (const struct __ns1__OperationCenter *)ptr);
		break;
	case SOAP_TYPE___ns1__OperationSms:
		soap_serialize___ns1__OperationSms(soap, (const struct __ns1__OperationSms *)ptr);
		break;
	case SOAP_TYPE_ns2__UpdateServerInfoResp:
		soap_serialize_ns2__UpdateServerInfoResp(soap, (const struct ns2__UpdateServerInfoResp *)ptr);
		break;
	case SOAP_TYPE_ns2__UpdateServerInfoReq:
		soap_serialize_ns2__UpdateServerInfoReq(soap, (const struct ns2__UpdateServerInfoReq *)ptr);
		break;
	case SOAP_TYPE_ns2__UpdateSysConfResp:
		soap_serialize_ns2__UpdateSysConfResp(soap, (const struct ns2__UpdateSysConfResp *)ptr);
		break;
	case SOAP_TYPE_ns2__UpdateSysConfReq:
		soap_serialize_ns2__UpdateSysConfReq(soap, (const struct ns2__UpdateSysConfReq *)ptr);
		break;
	case SOAP_TYPE_ns2__SetMileageResp:
		soap_serialize_ns2__SetMileageResp(soap, (const struct ns2__SetMileageResp *)ptr);
		break;
	case SOAP_TYPE_ns2__SetMileageReq:
		soap_serialize_ns2__SetMileageReq(soap, (const struct ns2__SetMileageReq *)ptr);
		break;
	case SOAP_TYPE_ns2__SetGPSFrequencyResp:
		soap_serialize_ns2__SetGPSFrequencyResp(soap, (const struct ns2__SetGPSFrequencyResp *)ptr);
		break;
	case SOAP_TYPE_ns2__SetGPSFrequencyReq:
		soap_serialize_ns2__SetGPSFrequencyReq(soap, (const struct ns2__SetGPSFrequencyReq *)ptr);
		break;
	case SOAP_TYPE_ns2__SendMsgResp:
		soap_serialize_ns2__SendMsgResp(soap, (const struct ns2__SendMsgResp *)ptr);
		break;
	case SOAP_TYPE_ns2__SendMsgReq:
		soap_serialize_ns2__SendMsgReq(soap, (const struct ns2__SendMsgReq *)ptr);
		break;
	case SOAP_TYPE_ns2__QueryVerResp:
		soap_serialize_ns2__QueryVerResp(soap, (const struct ns2__QueryVerResp *)ptr);
		break;
	case SOAP_TYPE_ns2__QueryVerReq:
		soap_serialize_ns2__QueryVerReq(soap, (const struct ns2__QueryVerReq *)ptr);
		break;
	case SOAP_TYPE_ns2__TakePhotoResp:
		soap_serialize_ns2__TakePhotoResp(soap, (const struct ns2__TakePhotoResp *)ptr);
		break;
	case SOAP_TYPE_ns2__TakePhotoReq:
		soap_serialize_ns2__TakePhotoReq(soap, (const struct ns2__TakePhotoReq *)ptr);
		break;
	case SOAP_TYPE__ns1__sayHelloResponse:
		soap_serialize__ns1__sayHelloResponse(soap, (const struct _ns1__sayHelloResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__sayHello:
		soap_serialize__ns1__sayHello(soap, (const struct _ns1__sayHello *)ptr);
		break;
	case SOAP_TYPE__ns1__OperationCenterResponse:
		soap_serialize__ns1__OperationCenterResponse(soap, (const struct _ns1__OperationCenterResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__OperationCenter:
		soap_serialize__ns1__OperationCenter(soap, (const struct _ns1__OperationCenter *)ptr);
		break;
	case SOAP_TYPE__ns1__OperationSmsResponse:
		soap_serialize__ns1__OperationSmsResponse(soap, (const struct _ns1__OperationSmsResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__OperationSms:
		soap_serialize__ns1__OperationSms(soap, (const struct _ns1__OperationSms *)ptr);
		break;
	case SOAP_TYPE_PointerTons3__updateServerInfoResponse:
		soap_serialize_PointerTons3__updateServerInfoResponse(soap, (struct ns3__updateServerInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UpdateServerInfoReq:
		soap_serialize_PointerTons2__UpdateServerInfoReq(soap, (struct ns2__UpdateServerInfoReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UpdateServerInfoResp:
		soap_serialize_PointerTons2__UpdateServerInfoResp(soap, (struct ns2__UpdateServerInfoResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__updateSysConfResponse:
		soap_serialize_PointerTons3__updateSysConfResponse(soap, (struct ns3__updateSysConfResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UpdateSysConfReq:
		soap_serialize_PointerTons2__UpdateSysConfReq(soap, (struct ns2__UpdateSysConfReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UpdateSysConfResp:
		soap_serialize_PointerTons2__UpdateSysConfResp(soap, (struct ns2__UpdateSysConfResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__setMileageResponse:
		soap_serialize_PointerTons3__setMileageResponse(soap, (struct ns3__setMileageResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SetMileageReq:
		soap_serialize_PointerTons2__SetMileageReq(soap, (struct ns2__SetMileageReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SetMileageResp:
		soap_serialize_PointerTons2__SetMileageResp(soap, (struct ns2__SetMileageResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__setGPSFrequencyResponse:
		soap_serialize_PointerTons3__setGPSFrequencyResponse(soap, (struct ns3__setGPSFrequencyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SetGPSFrequencyReq:
		soap_serialize_PointerTons2__SetGPSFrequencyReq(soap, (struct ns2__SetGPSFrequencyReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SetGPSFrequencyResp:
		soap_serialize_PointerTons2__SetGPSFrequencyResp(soap, (struct ns2__SetGPSFrequencyResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__sendMessageResponse:
		soap_serialize_PointerTons3__sendMessageResponse(soap, (struct ns3__sendMessageResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SendMsgReq:
		soap_serialize_PointerTons2__SendMsgReq(soap, (struct ns2__SendMsgReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SendMsgResp:
		soap_serialize_PointerTons2__SendMsgResp(soap, (struct ns2__SendMsgResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__queryVersionResponse:
		soap_serialize_PointerTons3__queryVersionResponse(soap, (struct ns3__queryVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__QueryVerReq:
		soap_serialize_PointerTons2__QueryVerReq(soap, (struct ns2__QueryVerReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__QueryVerResp:
		soap_serialize_PointerTons2__QueryVerResp(soap, (struct ns2__QueryVerResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__takePhotoResponse:
		soap_serialize_PointerTons3__takePhotoResponse(soap, (struct ns3__takePhotoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TakePhotoReq:
		soap_serialize_PointerTons2__TakePhotoReq(soap, (struct ns2__TakePhotoReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TakePhotoResp:
		soap_serialize_PointerTons2__TakePhotoResp(soap, (struct ns2__TakePhotoResp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__sayHelloResponse:
		soap_serialize_PointerTo_ns1__sayHelloResponse(soap, (struct _ns1__sayHelloResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__sayHello:
		soap_serialize_PointerTo_ns1__sayHello(soap, (struct _ns1__sayHello *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OperationCenterResponse:
		soap_serialize_PointerTo_ns1__OperationCenterResponse(soap, (struct _ns1__OperationCenterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OperationCenter:
		soap_serialize_PointerTo_ns1__OperationCenter(soap, (struct _ns1__OperationCenter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OperationSmsResponse:
		soap_serialize_PointerTo_ns1__OperationSmsResponse(soap, (struct _ns1__OperationSmsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OperationSms:
		soap_serialize_PointerTo_ns1__OperationSms(soap, (struct _ns1__OperationSms *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__updateServerInfo(struct soap *soap, struct ns3__updateServerInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__updateServerInfo(struct soap *soap, const struct ns3__updateServerInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__UpdateServerInfoReq(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__updateServerInfo(struct soap *soap, const struct ns3__updateServerInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__updateServerInfo);
	if (soap_out_ns3__updateServerInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__updateServerInfo(struct soap *soap, const char *tag, int id, const struct ns3__updateServerInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__updateServerInfo), type))
		return soap->error;
	if (soap_out_PointerTons2__UpdateServerInfoReq(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__updateServerInfo * SOAP_FMAC4 soap_get_ns3__updateServerInfo(struct soap *soap, struct ns3__updateServerInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__updateServerInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__updateServerInfo * SOAP_FMAC4 soap_in_ns3__updateServerInfo(struct soap *soap, const char *tag, struct ns3__updateServerInfo *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__updateServerInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__updateServerInfo, sizeof(struct ns3__updateServerInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__updateServerInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UpdateServerInfoReq(soap, NULL, &a->_in0, "ns2:UpdateServerInfoReq"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__updateServerInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__updateServerInfo, 0, sizeof(struct ns3__updateServerInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__updateServerInfoResponse(struct soap *soap, struct ns3__updateServerInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_updateServerInfoReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__updateServerInfoResponse(struct soap *soap, const struct ns3__updateServerInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__UpdateServerInfoResp(soap, &a->_updateServerInfoReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__updateServerInfoResponse(struct soap *soap, const struct ns3__updateServerInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__updateServerInfoResponse);
	if (soap_out_ns3__updateServerInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__updateServerInfoResponse(struct soap *soap, const char *tag, int id, const struct ns3__updateServerInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__updateServerInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__UpdateServerInfoResp(soap, "updateServerInfoReturn", -1, &a->_updateServerInfoReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__updateServerInfoResponse * SOAP_FMAC4 soap_get_ns3__updateServerInfoResponse(struct soap *soap, struct ns3__updateServerInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__updateServerInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__updateServerInfoResponse * SOAP_FMAC4 soap_in_ns3__updateServerInfoResponse(struct soap *soap, const char *tag, struct ns3__updateServerInfoResponse *a, const char *type)
{
	short soap_flag__updateServerInfoReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__updateServerInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__updateServerInfoResponse, sizeof(struct ns3__updateServerInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__updateServerInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__updateServerInfoReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UpdateServerInfoResp(soap, NULL, &a->_updateServerInfoReturn, "ns2:UpdateServerInfoResp"))
				{	soap_flag__updateServerInfoReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__updateServerInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__updateServerInfoResponse, 0, sizeof(struct ns3__updateServerInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__updateSysConf(struct soap *soap, struct ns3__updateSysConf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__updateSysConf(struct soap *soap, const struct ns3__updateSysConf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__UpdateSysConfReq(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__updateSysConf(struct soap *soap, const struct ns3__updateSysConf *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__updateSysConf);
	if (soap_out_ns3__updateSysConf(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__updateSysConf(struct soap *soap, const char *tag, int id, const struct ns3__updateSysConf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__updateSysConf), type))
		return soap->error;
	if (soap_out_PointerTons2__UpdateSysConfReq(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__updateSysConf * SOAP_FMAC4 soap_get_ns3__updateSysConf(struct soap *soap, struct ns3__updateSysConf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__updateSysConf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__updateSysConf * SOAP_FMAC4 soap_in_ns3__updateSysConf(struct soap *soap, const char *tag, struct ns3__updateSysConf *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__updateSysConf *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__updateSysConf, sizeof(struct ns3__updateSysConf), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__updateSysConf(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UpdateSysConfReq(soap, NULL, &a->_in0, "ns2:UpdateSysConfReq"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__updateSysConf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__updateSysConf, 0, sizeof(struct ns3__updateSysConf), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__updateSysConfResponse(struct soap *soap, struct ns3__updateSysConfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_updateSysConfReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__updateSysConfResponse(struct soap *soap, const struct ns3__updateSysConfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__UpdateSysConfResp(soap, &a->_updateSysConfReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__updateSysConfResponse(struct soap *soap, const struct ns3__updateSysConfResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__updateSysConfResponse);
	if (soap_out_ns3__updateSysConfResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__updateSysConfResponse(struct soap *soap, const char *tag, int id, const struct ns3__updateSysConfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__updateSysConfResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__UpdateSysConfResp(soap, "updateSysConfReturn", -1, &a->_updateSysConfReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__updateSysConfResponse * SOAP_FMAC4 soap_get_ns3__updateSysConfResponse(struct soap *soap, struct ns3__updateSysConfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__updateSysConfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__updateSysConfResponse * SOAP_FMAC4 soap_in_ns3__updateSysConfResponse(struct soap *soap, const char *tag, struct ns3__updateSysConfResponse *a, const char *type)
{
	short soap_flag__updateSysConfReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__updateSysConfResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__updateSysConfResponse, sizeof(struct ns3__updateSysConfResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__updateSysConfResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__updateSysConfReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UpdateSysConfResp(soap, NULL, &a->_updateSysConfReturn, "ns2:UpdateSysConfResp"))
				{	soap_flag__updateSysConfReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__updateSysConfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__updateSysConfResponse, 0, sizeof(struct ns3__updateSysConfResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__setMileage(struct soap *soap, struct ns3__setMileage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__setMileage(struct soap *soap, const struct ns3__setMileage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SetMileageReq(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__setMileage(struct soap *soap, const struct ns3__setMileage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__setMileage);
	if (soap_out_ns3__setMileage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__setMileage(struct soap *soap, const char *tag, int id, const struct ns3__setMileage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__setMileage), type))
		return soap->error;
	if (soap_out_PointerTons2__SetMileageReq(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__setMileage * SOAP_FMAC4 soap_get_ns3__setMileage(struct soap *soap, struct ns3__setMileage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__setMileage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__setMileage * SOAP_FMAC4 soap_in_ns3__setMileage(struct soap *soap, const char *tag, struct ns3__setMileage *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__setMileage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__setMileage, sizeof(struct ns3__setMileage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__setMileage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SetMileageReq(soap, NULL, &a->_in0, "ns2:SetMileageReq"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__setMileage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__setMileage, 0, sizeof(struct ns3__setMileage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__setMileageResponse(struct soap *soap, struct ns3__setMileageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_setMileageReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__setMileageResponse(struct soap *soap, const struct ns3__setMileageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SetMileageResp(soap, &a->_setMileageReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__setMileageResponse(struct soap *soap, const struct ns3__setMileageResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__setMileageResponse);
	if (soap_out_ns3__setMileageResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__setMileageResponse(struct soap *soap, const char *tag, int id, const struct ns3__setMileageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__setMileageResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__SetMileageResp(soap, "setMileageReturn", -1, &a->_setMileageReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__setMileageResponse * SOAP_FMAC4 soap_get_ns3__setMileageResponse(struct soap *soap, struct ns3__setMileageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__setMileageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__setMileageResponse * SOAP_FMAC4 soap_in_ns3__setMileageResponse(struct soap *soap, const char *tag, struct ns3__setMileageResponse *a, const char *type)
{
	short soap_flag__setMileageReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__setMileageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__setMileageResponse, sizeof(struct ns3__setMileageResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__setMileageResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__setMileageReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SetMileageResp(soap, NULL, &a->_setMileageReturn, "ns2:SetMileageResp"))
				{	soap_flag__setMileageReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__setMileageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__setMileageResponse, 0, sizeof(struct ns3__setMileageResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__setGPSFrequency(struct soap *soap, struct ns3__setGPSFrequency *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__setGPSFrequency(struct soap *soap, const struct ns3__setGPSFrequency *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SetGPSFrequencyReq(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__setGPSFrequency(struct soap *soap, const struct ns3__setGPSFrequency *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__setGPSFrequency);
	if (soap_out_ns3__setGPSFrequency(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__setGPSFrequency(struct soap *soap, const char *tag, int id, const struct ns3__setGPSFrequency *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__setGPSFrequency), type))
		return soap->error;
	if (soap_out_PointerTons2__SetGPSFrequencyReq(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__setGPSFrequency * SOAP_FMAC4 soap_get_ns3__setGPSFrequency(struct soap *soap, struct ns3__setGPSFrequency *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__setGPSFrequency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__setGPSFrequency * SOAP_FMAC4 soap_in_ns3__setGPSFrequency(struct soap *soap, const char *tag, struct ns3__setGPSFrequency *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__setGPSFrequency *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__setGPSFrequency, sizeof(struct ns3__setGPSFrequency), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__setGPSFrequency(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SetGPSFrequencyReq(soap, NULL, &a->_in0, "ns2:SetGPSFrequencyReq"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__setGPSFrequency *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__setGPSFrequency, 0, sizeof(struct ns3__setGPSFrequency), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__setGPSFrequencyResponse(struct soap *soap, struct ns3__setGPSFrequencyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_setGPSFrequencyReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__setGPSFrequencyResponse(struct soap *soap, const struct ns3__setGPSFrequencyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SetGPSFrequencyResp(soap, &a->_setGPSFrequencyReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__setGPSFrequencyResponse(struct soap *soap, const struct ns3__setGPSFrequencyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__setGPSFrequencyResponse);
	if (soap_out_ns3__setGPSFrequencyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__setGPSFrequencyResponse(struct soap *soap, const char *tag, int id, const struct ns3__setGPSFrequencyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__setGPSFrequencyResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__SetGPSFrequencyResp(soap, "setGPSFrequencyReturn", -1, &a->_setGPSFrequencyReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__setGPSFrequencyResponse * SOAP_FMAC4 soap_get_ns3__setGPSFrequencyResponse(struct soap *soap, struct ns3__setGPSFrequencyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__setGPSFrequencyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__setGPSFrequencyResponse * SOAP_FMAC4 soap_in_ns3__setGPSFrequencyResponse(struct soap *soap, const char *tag, struct ns3__setGPSFrequencyResponse *a, const char *type)
{
	short soap_flag__setGPSFrequencyReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__setGPSFrequencyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__setGPSFrequencyResponse, sizeof(struct ns3__setGPSFrequencyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__setGPSFrequencyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__setGPSFrequencyReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SetGPSFrequencyResp(soap, NULL, &a->_setGPSFrequencyReturn, "ns2:SetGPSFrequencyResp"))
				{	soap_flag__setGPSFrequencyReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__setGPSFrequencyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__setGPSFrequencyResponse, 0, sizeof(struct ns3__setGPSFrequencyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__sendMessage(struct soap *soap, struct ns3__sendMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__sendMessage(struct soap *soap, const struct ns3__sendMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SendMsgReq(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__sendMessage(struct soap *soap, const struct ns3__sendMessage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__sendMessage);
	if (soap_out_ns3__sendMessage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__sendMessage(struct soap *soap, const char *tag, int id, const struct ns3__sendMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__sendMessage), type))
		return soap->error;
	if (soap_out_PointerTons2__SendMsgReq(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__sendMessage * SOAP_FMAC4 soap_get_ns3__sendMessage(struct soap *soap, struct ns3__sendMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__sendMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__sendMessage * SOAP_FMAC4 soap_in_ns3__sendMessage(struct soap *soap, const char *tag, struct ns3__sendMessage *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__sendMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__sendMessage, sizeof(struct ns3__sendMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__sendMessage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SendMsgReq(soap, NULL, &a->_in0, "ns2:SendMsgReq"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__sendMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__sendMessage, 0, sizeof(struct ns3__sendMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__sendMessageResponse(struct soap *soap, struct ns3__sendMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_sendMessageReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__sendMessageResponse(struct soap *soap, const struct ns3__sendMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SendMsgResp(soap, &a->_sendMessageReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__sendMessageResponse(struct soap *soap, const struct ns3__sendMessageResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__sendMessageResponse);
	if (soap_out_ns3__sendMessageResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__sendMessageResponse(struct soap *soap, const char *tag, int id, const struct ns3__sendMessageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__sendMessageResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__SendMsgResp(soap, "sendMessageReturn", -1, &a->_sendMessageReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__sendMessageResponse * SOAP_FMAC4 soap_get_ns3__sendMessageResponse(struct soap *soap, struct ns3__sendMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__sendMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__sendMessageResponse * SOAP_FMAC4 soap_in_ns3__sendMessageResponse(struct soap *soap, const char *tag, struct ns3__sendMessageResponse *a, const char *type)
{
	short soap_flag__sendMessageReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__sendMessageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__sendMessageResponse, sizeof(struct ns3__sendMessageResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__sendMessageResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__sendMessageReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SendMsgResp(soap, NULL, &a->_sendMessageReturn, "ns2:SendMsgResp"))
				{	soap_flag__sendMessageReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__sendMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__sendMessageResponse, 0, sizeof(struct ns3__sendMessageResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__queryVersion(struct soap *soap, struct ns3__queryVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__queryVersion(struct soap *soap, const struct ns3__queryVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__QueryVerReq(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__queryVersion(struct soap *soap, const struct ns3__queryVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__queryVersion);
	if (soap_out_ns3__queryVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__queryVersion(struct soap *soap, const char *tag, int id, const struct ns3__queryVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__queryVersion), type))
		return soap->error;
	if (soap_out_PointerTons2__QueryVerReq(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__queryVersion * SOAP_FMAC4 soap_get_ns3__queryVersion(struct soap *soap, struct ns3__queryVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__queryVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__queryVersion * SOAP_FMAC4 soap_in_ns3__queryVersion(struct soap *soap, const char *tag, struct ns3__queryVersion *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__queryVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__queryVersion, sizeof(struct ns3__queryVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__queryVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__QueryVerReq(soap, NULL, &a->_in0, "ns2:QueryVerReq"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__queryVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__queryVersion, 0, sizeof(struct ns3__queryVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__queryVersionResponse(struct soap *soap, struct ns3__queryVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_queryVersionReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__queryVersionResponse(struct soap *soap, const struct ns3__queryVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__QueryVerResp(soap, &a->_queryVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__queryVersionResponse(struct soap *soap, const struct ns3__queryVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__queryVersionResponse);
	if (soap_out_ns3__queryVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__queryVersionResponse(struct soap *soap, const char *tag, int id, const struct ns3__queryVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__queryVersionResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__QueryVerResp(soap, "queryVersionReturn", -1, &a->_queryVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__queryVersionResponse * SOAP_FMAC4 soap_get_ns3__queryVersionResponse(struct soap *soap, struct ns3__queryVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__queryVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__queryVersionResponse * SOAP_FMAC4 soap_in_ns3__queryVersionResponse(struct soap *soap, const char *tag, struct ns3__queryVersionResponse *a, const char *type)
{
	short soap_flag__queryVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__queryVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__queryVersionResponse, sizeof(struct ns3__queryVersionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__queryVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__queryVersionReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__QueryVerResp(soap, NULL, &a->_queryVersionReturn, "ns2:QueryVerResp"))
				{	soap_flag__queryVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__queryVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__queryVersionResponse, 0, sizeof(struct ns3__queryVersionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__takePhoto(struct soap *soap, struct ns3__takePhoto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__takePhoto(struct soap *soap, const struct ns3__takePhoto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__TakePhotoReq(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__takePhoto(struct soap *soap, const struct ns3__takePhoto *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__takePhoto);
	if (soap_out_ns3__takePhoto(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__takePhoto(struct soap *soap, const char *tag, int id, const struct ns3__takePhoto *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__takePhoto), type))
		return soap->error;
	if (soap_out_PointerTons2__TakePhotoReq(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__takePhoto * SOAP_FMAC4 soap_get_ns3__takePhoto(struct soap *soap, struct ns3__takePhoto *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__takePhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__takePhoto * SOAP_FMAC4 soap_in_ns3__takePhoto(struct soap *soap, const char *tag, struct ns3__takePhoto *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__takePhoto *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__takePhoto, sizeof(struct ns3__takePhoto), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__takePhoto(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TakePhotoReq(soap, NULL, &a->_in0, "ns2:TakePhotoReq"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__takePhoto *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__takePhoto, 0, sizeof(struct ns3__takePhoto), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__takePhotoResponse(struct soap *soap, struct ns3__takePhotoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_takePhotoReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__takePhotoResponse(struct soap *soap, const struct ns3__takePhotoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__TakePhotoResp(soap, &a->_takePhotoReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__takePhotoResponse(struct soap *soap, const struct ns3__takePhotoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__takePhotoResponse);
	if (soap_out_ns3__takePhotoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__takePhotoResponse(struct soap *soap, const char *tag, int id, const struct ns3__takePhotoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__takePhotoResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__TakePhotoResp(soap, "takePhotoReturn", -1, &a->_takePhotoReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__takePhotoResponse * SOAP_FMAC4 soap_get_ns3__takePhotoResponse(struct soap *soap, struct ns3__takePhotoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__takePhotoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__takePhotoResponse * SOAP_FMAC4 soap_in_ns3__takePhotoResponse(struct soap *soap, const char *tag, struct ns3__takePhotoResponse *a, const char *type)
{
	short soap_flag__takePhotoReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__takePhotoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__takePhotoResponse, sizeof(struct ns3__takePhotoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__takePhotoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__takePhotoReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TakePhotoResp(soap, NULL, &a->_takePhotoReturn, "ns2:TakePhotoResp"))
				{	soap_flag__takePhotoReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__takePhotoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__takePhotoResponse, 0, sizeof(struct ns3__takePhotoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sayHello(struct soap *soap, struct __ns1__sayHello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sayHello = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sayHello(struct soap *soap, const struct __ns1__sayHello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__sayHello(soap, &a->ns1__sayHello);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sayHello(struct soap *soap, const struct __ns1__sayHello *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sayHello(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sayHello(struct soap *soap, const char *tag, int id, const struct __ns1__sayHello *a, const char *type)
{
	if (soap_out_PointerTo_ns1__sayHello(soap, "ns1:sayHello", -1, &a->ns1__sayHello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sayHello * SOAP_FMAC4 soap_get___ns1__sayHello(struct soap *soap, struct __ns1__sayHello *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sayHello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__sayHello * SOAP_FMAC4 soap_in___ns1__sayHello(struct soap *soap, const char *tag, struct __ns1__sayHello *a, const char *type)
{
	short soap_flag_ns1__sayHello = 1;
	short soap_flag;
	a = (struct __ns1__sayHello *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sayHello, sizeof(struct __ns1__sayHello), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sayHello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sayHello && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__sayHello(soap, "ns1:sayHello", &a->ns1__sayHello, ""))
				{	soap_flag_ns1__sayHello--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OperationCenter(struct soap *soap, struct __ns1__OperationCenter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OperationCenter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OperationCenter(struct soap *soap, const struct __ns1__OperationCenter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__OperationCenter(soap, &a->ns1__OperationCenter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OperationCenter(struct soap *soap, const struct __ns1__OperationCenter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__OperationCenter(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OperationCenter(struct soap *soap, const char *tag, int id, const struct __ns1__OperationCenter *a, const char *type)
{
	if (soap_out_PointerTo_ns1__OperationCenter(soap, "ns1:OperationCenter", -1, &a->ns1__OperationCenter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OperationCenter * SOAP_FMAC4 soap_get___ns1__OperationCenter(struct soap *soap, struct __ns1__OperationCenter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OperationCenter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__OperationCenter * SOAP_FMAC4 soap_in___ns1__OperationCenter(struct soap *soap, const char *tag, struct __ns1__OperationCenter *a, const char *type)
{
	short soap_flag_ns1__OperationCenter = 1;
	short soap_flag;
	a = (struct __ns1__OperationCenter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OperationCenter, sizeof(struct __ns1__OperationCenter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OperationCenter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OperationCenter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OperationCenter(soap, "ns1:OperationCenter", &a->ns1__OperationCenter, ""))
				{	soap_flag_ns1__OperationCenter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OperationSms(struct soap *soap, struct __ns1__OperationSms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OperationSms = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OperationSms(struct soap *soap, const struct __ns1__OperationSms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__OperationSms(soap, &a->ns1__OperationSms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OperationSms(struct soap *soap, const struct __ns1__OperationSms *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__OperationSms(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OperationSms(struct soap *soap, const char *tag, int id, const struct __ns1__OperationSms *a, const char *type)
{
	if (soap_out_PointerTo_ns1__OperationSms(soap, "ns1:OperationSms", -1, &a->ns1__OperationSms, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OperationSms * SOAP_FMAC4 soap_get___ns1__OperationSms(struct soap *soap, struct __ns1__OperationSms *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OperationSms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__OperationSms * SOAP_FMAC4 soap_in___ns1__OperationSms(struct soap *soap, const char *tag, struct __ns1__OperationSms *a, const char *type)
{
	short soap_flag_ns1__OperationSms = 1;
	short soap_flag;
	a = (struct __ns1__OperationSms *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OperationSms, sizeof(struct __ns1__OperationSms), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OperationSms(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OperationSms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OperationSms(soap, "ns1:OperationSms", &a->ns1__OperationSms, ""))
				{	soap_flag_ns1__OperationSms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__UpdateServerInfoResp(struct soap *soap, struct ns2__UpdateServerInfoResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__UpdateServerInfoResp(struct soap *soap, const struct ns2__UpdateServerInfoResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UpdateServerInfoResp(struct soap *soap, const struct ns2__UpdateServerInfoResp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__UpdateServerInfoResp);
	if (soap_out_ns2__UpdateServerInfoResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UpdateServerInfoResp(struct soap *soap, const char *tag, int id, const struct ns2__UpdateServerInfoResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UpdateServerInfoResp), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__UpdateServerInfoResp * SOAP_FMAC4 soap_get_ns2__UpdateServerInfoResp(struct soap *soap, struct ns2__UpdateServerInfoResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UpdateServerInfoResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__UpdateServerInfoResp * SOAP_FMAC4 soap_in_ns2__UpdateServerInfoResp(struct soap *soap, const char *tag, struct ns2__UpdateServerInfoResp *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__UpdateServerInfoResp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UpdateServerInfoResp, sizeof(struct ns2__UpdateServerInfoResp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__UpdateServerInfoResp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__UpdateServerInfoResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UpdateServerInfoResp, 0, sizeof(struct ns2__UpdateServerInfoResp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__UpdateServerInfoReq(struct soap *soap, struct ns2__UpdateServerInfoReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->logServerIp);
	soap_default_int(soap, &a->logServerPort);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->simPhone);
	soap_default_string(soap, &a->updateServerIp);
	soap_default_int(soap, &a->updateServerPort);
	soap_default_string(soap, &a->userName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__UpdateServerInfoReq(struct soap *soap, const struct ns2__UpdateServerInfoReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->logServerIp);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->simPhone);
	soap_serialize_string(soap, &a->updateServerIp);
	soap_serialize_string(soap, &a->userName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UpdateServerInfoReq(struct soap *soap, const struct ns2__UpdateServerInfoReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__UpdateServerInfoReq);
	if (soap_out_ns2__UpdateServerInfoReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UpdateServerInfoReq(struct soap *soap, const char *tag, int id, const struct ns2__UpdateServerInfoReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UpdateServerInfoReq), type))
		return soap->error;
	if (soap_out_string(soap, "logServerIp", -1, &a->logServerIp, ""))
		return soap->error;
	if (soap_out_int(soap, "logServerPort", -1, &a->logServerPort, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "simPhone", -1, &a->simPhone, ""))
		return soap->error;
	if (soap_out_string(soap, "updateServerIp", -1, &a->updateServerIp, ""))
		return soap->error;
	if (soap_out_int(soap, "updateServerPort", -1, &a->updateServerPort, ""))
		return soap->error;
	if (soap_out_string(soap, "userName", -1, &a->userName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__UpdateServerInfoReq * SOAP_FMAC4 soap_get_ns2__UpdateServerInfoReq(struct soap *soap, struct ns2__UpdateServerInfoReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UpdateServerInfoReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__UpdateServerInfoReq * SOAP_FMAC4 soap_in_ns2__UpdateServerInfoReq(struct soap *soap, const char *tag, struct ns2__UpdateServerInfoReq *a, const char *type)
{
	short soap_flag_logServerIp = 1, soap_flag_logServerPort = 1, soap_flag_password = 1, soap_flag_simPhone = 1, soap_flag_updateServerIp = 1, soap_flag_updateServerPort = 1, soap_flag_userName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__UpdateServerInfoReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UpdateServerInfoReq, sizeof(struct ns2__UpdateServerInfoReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__UpdateServerInfoReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_logServerIp && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "logServerIp", &a->logServerIp, "xsd:string"))
				{	soap_flag_logServerIp--;
					continue;
				}
			if (soap_flag_logServerPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "logServerPort", &a->logServerPort, "xsd:int"))
				{	soap_flag_logServerPort--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_simPhone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simPhone", &a->simPhone, "xsd:string"))
				{	soap_flag_simPhone--;
					continue;
				}
			if (soap_flag_updateServerIp && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "updateServerIp", &a->updateServerIp, "xsd:string"))
				{	soap_flag_updateServerIp--;
					continue;
				}
			if (soap_flag_updateServerPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "updateServerPort", &a->updateServerPort, "xsd:int"))
				{	soap_flag_updateServerPort--;
					continue;
				}
			if (soap_flag_userName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &a->userName, "xsd:string"))
				{	soap_flag_userName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__UpdateServerInfoReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UpdateServerInfoReq, 0, sizeof(struct ns2__UpdateServerInfoReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_logServerPort > 0 || soap_flag_updateServerPort > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__UpdateSysConfResp(struct soap *soap, struct ns2__UpdateSysConfResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__UpdateSysConfResp(struct soap *soap, const struct ns2__UpdateSysConfResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UpdateSysConfResp(struct soap *soap, const struct ns2__UpdateSysConfResp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__UpdateSysConfResp);
	if (soap_out_ns2__UpdateSysConfResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UpdateSysConfResp(struct soap *soap, const char *tag, int id, const struct ns2__UpdateSysConfResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UpdateSysConfResp), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__UpdateSysConfResp * SOAP_FMAC4 soap_get_ns2__UpdateSysConfResp(struct soap *soap, struct ns2__UpdateSysConfResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UpdateSysConfResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__UpdateSysConfResp * SOAP_FMAC4 soap_in_ns2__UpdateSysConfResp(struct soap *soap, const char *tag, struct ns2__UpdateSysConfResp *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__UpdateSysConfResp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UpdateSysConfResp, sizeof(struct ns2__UpdateSysConfResp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__UpdateSysConfResp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__UpdateSysConfResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UpdateSysConfResp, 0, sizeof(struct ns2__UpdateSysConfResp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__UpdateSysConfReq(struct soap *soap, struct ns2__UpdateSysConfReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->command);
	soap_default_string(soap, &a->simPhone);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__UpdateSysConfReq(struct soap *soap, const struct ns2__UpdateSysConfReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->command);
	soap_serialize_string(soap, &a->simPhone);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UpdateSysConfReq(struct soap *soap, const struct ns2__UpdateSysConfReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__UpdateSysConfReq);
	if (soap_out_ns2__UpdateSysConfReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UpdateSysConfReq(struct soap *soap, const char *tag, int id, const struct ns2__UpdateSysConfReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UpdateSysConfReq), type))
		return soap->error;
	if (soap_out_string(soap, "command", -1, &a->command, ""))
		return soap->error;
	if (soap_out_string(soap, "simPhone", -1, &a->simPhone, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__UpdateSysConfReq * SOAP_FMAC4 soap_get_ns2__UpdateSysConfReq(struct soap *soap, struct ns2__UpdateSysConfReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UpdateSysConfReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__UpdateSysConfReq * SOAP_FMAC4 soap_in_ns2__UpdateSysConfReq(struct soap *soap, const char *tag, struct ns2__UpdateSysConfReq *a, const char *type)
{
	short soap_flag_command = 1, soap_flag_simPhone = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__UpdateSysConfReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UpdateSysConfReq, sizeof(struct ns2__UpdateSysConfReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__UpdateSysConfReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_command && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "command", &a->command, "xsd:string"))
				{	soap_flag_command--;
					continue;
				}
			if (soap_flag_simPhone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simPhone", &a->simPhone, "xsd:string"))
				{	soap_flag_simPhone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__UpdateSysConfReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UpdateSysConfReq, 0, sizeof(struct ns2__UpdateSysConfReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SetMileageResp(struct soap *soap, struct ns2__SetMileageResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SetMileageResp(struct soap *soap, const struct ns2__SetMileageResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SetMileageResp(struct soap *soap, const struct ns2__SetMileageResp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SetMileageResp);
	if (soap_out_ns2__SetMileageResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SetMileageResp(struct soap *soap, const char *tag, int id, const struct ns2__SetMileageResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SetMileageResp), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SetMileageResp * SOAP_FMAC4 soap_get_ns2__SetMileageResp(struct soap *soap, struct ns2__SetMileageResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SetMileageResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SetMileageResp * SOAP_FMAC4 soap_in_ns2__SetMileageResp(struct soap *soap, const char *tag, struct ns2__SetMileageResp *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SetMileageResp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SetMileageResp, sizeof(struct ns2__SetMileageResp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SetMileageResp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SetMileageResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SetMileageResp, 0, sizeof(struct ns2__SetMileageResp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SetMileageReq(struct soap *soap, struct ns2__SetMileageReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->mileageFloat);
	soap_default_int(soap, &a->mileageInt);
	soap_default_string(soap, &a->simPhone);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SetMileageReq(struct soap *soap, const struct ns2__SetMileageReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->simPhone);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SetMileageReq(struct soap *soap, const struct ns2__SetMileageReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SetMileageReq);
	if (soap_out_ns2__SetMileageReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SetMileageReq(struct soap *soap, const char *tag, int id, const struct ns2__SetMileageReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SetMileageReq), type))
		return soap->error;
	if (soap_out_int(soap, "mileageFloat", -1, &a->mileageFloat, ""))
		return soap->error;
	if (soap_out_int(soap, "mileageInt", -1, &a->mileageInt, ""))
		return soap->error;
	if (soap_out_string(soap, "simPhone", -1, &a->simPhone, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SetMileageReq * SOAP_FMAC4 soap_get_ns2__SetMileageReq(struct soap *soap, struct ns2__SetMileageReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SetMileageReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SetMileageReq * SOAP_FMAC4 soap_in_ns2__SetMileageReq(struct soap *soap, const char *tag, struct ns2__SetMileageReq *a, const char *type)
{
	short soap_flag_mileageFloat = 1, soap_flag_mileageInt = 1, soap_flag_simPhone = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SetMileageReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SetMileageReq, sizeof(struct ns2__SetMileageReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SetMileageReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mileageFloat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mileageFloat", &a->mileageFloat, "xsd:int"))
				{	soap_flag_mileageFloat--;
					continue;
				}
			if (soap_flag_mileageInt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mileageInt", &a->mileageInt, "xsd:int"))
				{	soap_flag_mileageInt--;
					continue;
				}
			if (soap_flag_simPhone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simPhone", &a->simPhone, "xsd:string"))
				{	soap_flag_simPhone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SetMileageReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SetMileageReq, 0, sizeof(struct ns2__SetMileageReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mileageFloat > 0 || soap_flag_mileageInt > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SetGPSFrequencyResp(struct soap *soap, struct ns2__SetGPSFrequencyResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SetGPSFrequencyResp(struct soap *soap, const struct ns2__SetGPSFrequencyResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SetGPSFrequencyResp(struct soap *soap, const struct ns2__SetGPSFrequencyResp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SetGPSFrequencyResp);
	if (soap_out_ns2__SetGPSFrequencyResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SetGPSFrequencyResp(struct soap *soap, const char *tag, int id, const struct ns2__SetGPSFrequencyResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SetGPSFrequencyResp), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SetGPSFrequencyResp * SOAP_FMAC4 soap_get_ns2__SetGPSFrequencyResp(struct soap *soap, struct ns2__SetGPSFrequencyResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SetGPSFrequencyResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SetGPSFrequencyResp * SOAP_FMAC4 soap_in_ns2__SetGPSFrequencyResp(struct soap *soap, const char *tag, struct ns2__SetGPSFrequencyResp *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SetGPSFrequencyResp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SetGPSFrequencyResp, sizeof(struct ns2__SetGPSFrequencyResp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SetGPSFrequencyResp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SetGPSFrequencyResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SetGPSFrequencyResp, 0, sizeof(struct ns2__SetGPSFrequencyResp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SetGPSFrequencyReq(struct soap *soap, struct ns2__SetGPSFrequencyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->interval);
	soap_default_string(soap, &a->simPhone);
	soap_default_int(soap, &a->times);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SetGPSFrequencyReq(struct soap *soap, const struct ns2__SetGPSFrequencyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->simPhone);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SetGPSFrequencyReq(struct soap *soap, const struct ns2__SetGPSFrequencyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SetGPSFrequencyReq);
	if (soap_out_ns2__SetGPSFrequencyReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SetGPSFrequencyReq(struct soap *soap, const char *tag, int id, const struct ns2__SetGPSFrequencyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SetGPSFrequencyReq), type))
		return soap->error;
	if (soap_out_int(soap, "interval", -1, &a->interval, ""))
		return soap->error;
	if (soap_out_string(soap, "simPhone", -1, &a->simPhone, ""))
		return soap->error;
	if (soap_out_int(soap, "times", -1, &a->times, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SetGPSFrequencyReq * SOAP_FMAC4 soap_get_ns2__SetGPSFrequencyReq(struct soap *soap, struct ns2__SetGPSFrequencyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SetGPSFrequencyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SetGPSFrequencyReq * SOAP_FMAC4 soap_in_ns2__SetGPSFrequencyReq(struct soap *soap, const char *tag, struct ns2__SetGPSFrequencyReq *a, const char *type)
{
	short soap_flag_interval = 1, soap_flag_simPhone = 1, soap_flag_times = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SetGPSFrequencyReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SetGPSFrequencyReq, sizeof(struct ns2__SetGPSFrequencyReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SetGPSFrequencyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_interval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "interval", &a->interval, "xsd:int"))
				{	soap_flag_interval--;
					continue;
				}
			if (soap_flag_simPhone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simPhone", &a->simPhone, "xsd:string"))
				{	soap_flag_simPhone--;
					continue;
				}
			if (soap_flag_times && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "times", &a->times, "xsd:int"))
				{	soap_flag_times--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SetGPSFrequencyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SetGPSFrequencyReq, 0, sizeof(struct ns2__SetGPSFrequencyReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_interval > 0 || soap_flag_times > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SendMsgResp(struct soap *soap, struct ns2__SendMsgResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SendMsgResp(struct soap *soap, const struct ns2__SendMsgResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SendMsgResp(struct soap *soap, const struct ns2__SendMsgResp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SendMsgResp);
	if (soap_out_ns2__SendMsgResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SendMsgResp(struct soap *soap, const char *tag, int id, const struct ns2__SendMsgResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SendMsgResp), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SendMsgResp * SOAP_FMAC4 soap_get_ns2__SendMsgResp(struct soap *soap, struct ns2__SendMsgResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SendMsgResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SendMsgResp * SOAP_FMAC4 soap_in_ns2__SendMsgResp(struct soap *soap, const char *tag, struct ns2__SendMsgResp *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SendMsgResp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SendMsgResp, sizeof(struct ns2__SendMsgResp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SendMsgResp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SendMsgResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SendMsgResp, 0, sizeof(struct ns2__SendMsgResp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SendMsgReq(struct soap *soap, struct ns2__SendMsgReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->message);
	soap_default_string(soap, &a->simPhone);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SendMsgReq(struct soap *soap, const struct ns2__SendMsgReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->message);
	soap_serialize_string(soap, &a->simPhone);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SendMsgReq(struct soap *soap, const struct ns2__SendMsgReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SendMsgReq);
	if (soap_out_ns2__SendMsgReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SendMsgReq(struct soap *soap, const char *tag, int id, const struct ns2__SendMsgReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SendMsgReq), type))
		return soap->error;
	if (soap_out_string(soap, "message", -1, &a->message, ""))
		return soap->error;
	if (soap_out_string(soap, "simPhone", -1, &a->simPhone, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SendMsgReq * SOAP_FMAC4 soap_get_ns2__SendMsgReq(struct soap *soap, struct ns2__SendMsgReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SendMsgReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SendMsgReq * SOAP_FMAC4 soap_in_ns2__SendMsgReq(struct soap *soap, const char *tag, struct ns2__SendMsgReq *a, const char *type)
{
	short soap_flag_message = 1, soap_flag_simPhone = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SendMsgReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SendMsgReq, sizeof(struct ns2__SendMsgReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SendMsgReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "message", &a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			if (soap_flag_simPhone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simPhone", &a->simPhone, "xsd:string"))
				{	soap_flag_simPhone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SendMsgReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SendMsgReq, 0, sizeof(struct ns2__SendMsgReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__QueryVerResp(struct soap *soap, struct ns2__QueryVerResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
	soap_default_string(soap, &a->version);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__QueryVerResp(struct soap *soap, const struct ns2__QueryVerResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->version);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__QueryVerResp(struct soap *soap, const struct ns2__QueryVerResp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__QueryVerResp);
	if (soap_out_ns2__QueryVerResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__QueryVerResp(struct soap *soap, const char *tag, int id, const struct ns2__QueryVerResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__QueryVerResp), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "version", -1, &a->version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__QueryVerResp * SOAP_FMAC4 soap_get_ns2__QueryVerResp(struct soap *soap, struct ns2__QueryVerResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__QueryVerResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__QueryVerResp * SOAP_FMAC4 soap_in_ns2__QueryVerResp(struct soap *soap, const char *tag, struct ns2__QueryVerResp *a, const char *type)
{
	short soap_flag_result = 1, soap_flag_version = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__QueryVerResp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__QueryVerResp, sizeof(struct ns2__QueryVerResp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__QueryVerResp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "version", &a->version, "xsd:string"))
				{	soap_flag_version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__QueryVerResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__QueryVerResp, 0, sizeof(struct ns2__QueryVerResp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__QueryVerReq(struct soap *soap, struct ns2__QueryVerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->simPhone);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__QueryVerReq(struct soap *soap, const struct ns2__QueryVerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->simPhone);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__QueryVerReq(struct soap *soap, const struct ns2__QueryVerReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__QueryVerReq);
	if (soap_out_ns2__QueryVerReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__QueryVerReq(struct soap *soap, const char *tag, int id, const struct ns2__QueryVerReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__QueryVerReq), type))
		return soap->error;
	if (soap_out_string(soap, "simPhone", -1, &a->simPhone, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__QueryVerReq * SOAP_FMAC4 soap_get_ns2__QueryVerReq(struct soap *soap, struct ns2__QueryVerReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__QueryVerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__QueryVerReq * SOAP_FMAC4 soap_in_ns2__QueryVerReq(struct soap *soap, const char *tag, struct ns2__QueryVerReq *a, const char *type)
{
	short soap_flag_simPhone = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__QueryVerReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__QueryVerReq, sizeof(struct ns2__QueryVerReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__QueryVerReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_simPhone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simPhone", &a->simPhone, "xsd:string"))
				{	soap_flag_simPhone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__QueryVerReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__QueryVerReq, 0, sizeof(struct ns2__QueryVerReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TakePhotoResp(struct soap *soap, struct ns2__TakePhotoResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->photoName);
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__TakePhotoResp(struct soap *soap, const struct ns2__TakePhotoResp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->photoName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TakePhotoResp(struct soap *soap, const struct ns2__TakePhotoResp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__TakePhotoResp);
	if (soap_out_ns2__TakePhotoResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TakePhotoResp(struct soap *soap, const char *tag, int id, const struct ns2__TakePhotoResp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TakePhotoResp), type))
		return soap->error;
	if (soap_out_string(soap, "photoName", -1, &a->photoName, ""))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__TakePhotoResp * SOAP_FMAC4 soap_get_ns2__TakePhotoResp(struct soap *soap, struct ns2__TakePhotoResp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TakePhotoResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__TakePhotoResp * SOAP_FMAC4 soap_in_ns2__TakePhotoResp(struct soap *soap, const char *tag, struct ns2__TakePhotoResp *a, const char *type)
{
	short soap_flag_photoName = 1, soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__TakePhotoResp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TakePhotoResp, sizeof(struct ns2__TakePhotoResp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__TakePhotoResp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_photoName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "photoName", &a->photoName, "xsd:string"))
				{	soap_flag_photoName--;
					continue;
				}
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__TakePhotoResp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TakePhotoResp, 0, sizeof(struct ns2__TakePhotoResp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TakePhotoReq(struct soap *soap, struct ns2__TakePhotoReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->action);
	soap_default_int(soap, &a->camID);
	soap_default_int(soap, &a->photoSize);
	soap_default_string(soap, &a->simPhone);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__TakePhotoReq(struct soap *soap, const struct ns2__TakePhotoReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->simPhone);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TakePhotoReq(struct soap *soap, const struct ns2__TakePhotoReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__TakePhotoReq);
	if (soap_out_ns2__TakePhotoReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TakePhotoReq(struct soap *soap, const char *tag, int id, const struct ns2__TakePhotoReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TakePhotoReq), type))
		return soap->error;
	if (soap_out_int(soap, "action", -1, &a->action, ""))
		return soap->error;
	if (soap_out_int(soap, "camID", -1, &a->camID, ""))
		return soap->error;
	if (soap_out_int(soap, "photoSize", -1, &a->photoSize, ""))
		return soap->error;
	if (soap_out_string(soap, "simPhone", -1, &a->simPhone, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__TakePhotoReq * SOAP_FMAC4 soap_get_ns2__TakePhotoReq(struct soap *soap, struct ns2__TakePhotoReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TakePhotoReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__TakePhotoReq * SOAP_FMAC4 soap_in_ns2__TakePhotoReq(struct soap *soap, const char *tag, struct ns2__TakePhotoReq *a, const char *type)
{
	short soap_flag_action = 1, soap_flag_camID = 1, soap_flag_photoSize = 1, soap_flag_simPhone = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__TakePhotoReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TakePhotoReq, sizeof(struct ns2__TakePhotoReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__TakePhotoReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_action && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "action", &a->action, "xsd:int"))
				{	soap_flag_action--;
					continue;
				}
			if (soap_flag_camID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "camID", &a->camID, "xsd:int"))
				{	soap_flag_camID--;
					continue;
				}
			if (soap_flag_photoSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "photoSize", &a->photoSize, "xsd:int"))
				{	soap_flag_photoSize--;
					continue;
				}
			if (soap_flag_simPhone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "simPhone", &a->simPhone, "xsd:string"))
				{	soap_flag_simPhone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__TakePhotoReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TakePhotoReq, 0, sizeof(struct ns2__TakePhotoReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_action > 0 || soap_flag_camID > 0 || soap_flag_photoSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__sayHelloResponse(struct soap *soap, struct _ns1__sayHelloResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__sayHelloResponse(struct soap *soap, const struct _ns1__sayHelloResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->out);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__sayHelloResponse(struct soap *soap, const struct _ns1__sayHelloResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__sayHelloResponse);
	if (soap_out__ns1__sayHelloResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sayHelloResponse(struct soap *soap, const char *tag, int id, const struct _ns1__sayHelloResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sayHelloResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (soap_out_string(soap, "ns1:out", -1, &a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__sayHelloResponse * SOAP_FMAC4 soap_get__ns1__sayHelloResponse(struct soap *soap, struct _ns1__sayHelloResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sayHelloResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__sayHelloResponse * SOAP_FMAC4 soap_in__ns1__sayHelloResponse(struct soap *soap, const char *tag, struct _ns1__sayHelloResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__sayHelloResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sayHelloResponse, sizeof(struct _ns1__sayHelloResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__sayHelloResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:out", &a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__sayHelloResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__sayHelloResponse, 0, sizeof(struct _ns1__sayHelloResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__sayHello(struct soap *soap, struct _ns1__sayHello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__sayHello(struct soap *soap, const struct _ns1__sayHello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__sayHello(struct soap *soap, const struct _ns1__sayHello *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__sayHello);
	if (soap_out__ns1__sayHello(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__sayHello(struct soap *soap, const char *tag, int id, const struct _ns1__sayHello *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__sayHello), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:in0", -1, &a->in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__sayHello * SOAP_FMAC4 soap_get__ns1__sayHello(struct soap *soap, struct _ns1__sayHello *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__sayHello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__sayHello * SOAP_FMAC4 soap_in__ns1__sayHello(struct soap *soap, const char *tag, struct _ns1__sayHello *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__sayHello *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__sayHello, sizeof(struct _ns1__sayHello), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__sayHello(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:in0", &a->in0, "xsd:string"))
				{	soap_flag_in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__sayHello *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__sayHello, 0, sizeof(struct _ns1__sayHello), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in0 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__OperationCenterResponse(struct soap *soap, struct _ns1__OperationCenterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__OperationCenterResponse(struct soap *soap, const struct _ns1__OperationCenterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->out);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__OperationCenterResponse(struct soap *soap, const struct _ns1__OperationCenterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__OperationCenterResponse);
	if (soap_out__ns1__OperationCenterResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OperationCenterResponse(struct soap *soap, const char *tag, int id, const struct _ns1__OperationCenterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OperationCenterResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (soap_out_string(soap, "ns1:out", -1, &a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__OperationCenterResponse * SOAP_FMAC4 soap_get__ns1__OperationCenterResponse(struct soap *soap, struct _ns1__OperationCenterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OperationCenterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__OperationCenterResponse * SOAP_FMAC4 soap_in__ns1__OperationCenterResponse(struct soap *soap, const char *tag, struct _ns1__OperationCenterResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__OperationCenterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OperationCenterResponse, sizeof(struct _ns1__OperationCenterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__OperationCenterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:out", &a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__OperationCenterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OperationCenterResponse, 0, sizeof(struct _ns1__OperationCenterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__OperationCenter(struct soap *soap, struct _ns1__OperationCenter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__OperationCenter(struct soap *soap, const struct _ns1__OperationCenter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__OperationCenter(struct soap *soap, const struct _ns1__OperationCenter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__OperationCenter);
	if (soap_out__ns1__OperationCenter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OperationCenter(struct soap *soap, const char *tag, int id, const struct _ns1__OperationCenter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OperationCenter), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:in0", -1, &a->in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__OperationCenter * SOAP_FMAC4 soap_get__ns1__OperationCenter(struct soap *soap, struct _ns1__OperationCenter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OperationCenter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__OperationCenter * SOAP_FMAC4 soap_in__ns1__OperationCenter(struct soap *soap, const char *tag, struct _ns1__OperationCenter *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__OperationCenter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OperationCenter, sizeof(struct _ns1__OperationCenter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__OperationCenter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:in0", &a->in0, "xsd:string"))
				{	soap_flag_in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__OperationCenter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OperationCenter, 0, sizeof(struct _ns1__OperationCenter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in0 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__OperationSmsResponse(struct soap *soap, struct _ns1__OperationSmsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__OperationSmsResponse(struct soap *soap, const struct _ns1__OperationSmsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->out);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__OperationSmsResponse(struct soap *soap, const struct _ns1__OperationSmsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__OperationSmsResponse);
	if (soap_out__ns1__OperationSmsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OperationSmsResponse(struct soap *soap, const char *tag, int id, const struct _ns1__OperationSmsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OperationSmsResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (soap_out_string(soap, "ns1:out", -1, &a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__OperationSmsResponse * SOAP_FMAC4 soap_get__ns1__OperationSmsResponse(struct soap *soap, struct _ns1__OperationSmsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OperationSmsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__OperationSmsResponse * SOAP_FMAC4 soap_in__ns1__OperationSmsResponse(struct soap *soap, const char *tag, struct _ns1__OperationSmsResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__OperationSmsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OperationSmsResponse, sizeof(struct _ns1__OperationSmsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__OperationSmsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:out", &a->out, "xsd:string"))
				{	soap_flag_out--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__OperationSmsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OperationSmsResponse, 0, sizeof(struct _ns1__OperationSmsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__OperationSms(struct soap *soap, struct _ns1__OperationSms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__OperationSms(struct soap *soap, const struct _ns1__OperationSms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__OperationSms(struct soap *soap, const struct _ns1__OperationSms *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__OperationSms);
	if (soap_out__ns1__OperationSms(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OperationSms(struct soap *soap, const char *tag, int id, const struct _ns1__OperationSms *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OperationSms), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:in0", -1, &a->in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__OperationSms * SOAP_FMAC4 soap_get__ns1__OperationSms(struct soap *soap, struct _ns1__OperationSms *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OperationSms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__OperationSms * SOAP_FMAC4 soap_in__ns1__OperationSms(struct soap *soap, const char *tag, struct _ns1__OperationSms *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__OperationSms *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OperationSms, sizeof(struct _ns1__OperationSms), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__OperationSms(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:in0", &a->in0, "xsd:string"))
				{	soap_flag_in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__OperationSms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OperationSms, 0, sizeof(struct _ns1__OperationSms), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in0 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__updateServerInfoResponse(struct soap *soap, struct ns3__updateServerInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__updateServerInfoResponse))
		soap_serialize_ns3__updateServerInfoResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__updateServerInfoResponse(struct soap *soap, struct ns3__updateServerInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__updateServerInfoResponse);
	if (soap_out_PointerTons3__updateServerInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__updateServerInfoResponse(struct soap *soap, const char *tag, int id, struct ns3__updateServerInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__updateServerInfoResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__updateServerInfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__updateServerInfoResponse ** SOAP_FMAC4 soap_get_PointerTons3__updateServerInfoResponse(struct soap *soap, struct ns3__updateServerInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__updateServerInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__updateServerInfoResponse ** SOAP_FMAC4 soap_in_PointerTons3__updateServerInfoResponse(struct soap *soap, const char *tag, struct ns3__updateServerInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__updateServerInfoResponse **)soap_malloc(soap, sizeof(struct ns3__updateServerInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__updateServerInfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__updateServerInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__updateServerInfoResponse, sizeof(struct ns3__updateServerInfoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UpdateServerInfoReq(struct soap *soap, struct ns2__UpdateServerInfoReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UpdateServerInfoReq))
		soap_serialize_ns2__UpdateServerInfoReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UpdateServerInfoReq(struct soap *soap, struct ns2__UpdateServerInfoReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UpdateServerInfoReq);
	if (soap_out_PointerTons2__UpdateServerInfoReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UpdateServerInfoReq(struct soap *soap, const char *tag, int id, struct ns2__UpdateServerInfoReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UpdateServerInfoReq);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__UpdateServerInfoReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__UpdateServerInfoReq ** SOAP_FMAC4 soap_get_PointerTons2__UpdateServerInfoReq(struct soap *soap, struct ns2__UpdateServerInfoReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UpdateServerInfoReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__UpdateServerInfoReq ** SOAP_FMAC4 soap_in_PointerTons2__UpdateServerInfoReq(struct soap *soap, const char *tag, struct ns2__UpdateServerInfoReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__UpdateServerInfoReq **)soap_malloc(soap, sizeof(struct ns2__UpdateServerInfoReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__UpdateServerInfoReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__UpdateServerInfoReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UpdateServerInfoReq, sizeof(struct ns2__UpdateServerInfoReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UpdateServerInfoResp(struct soap *soap, struct ns2__UpdateServerInfoResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UpdateServerInfoResp))
		soap_serialize_ns2__UpdateServerInfoResp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UpdateServerInfoResp(struct soap *soap, struct ns2__UpdateServerInfoResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UpdateServerInfoResp);
	if (soap_out_PointerTons2__UpdateServerInfoResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UpdateServerInfoResp(struct soap *soap, const char *tag, int id, struct ns2__UpdateServerInfoResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UpdateServerInfoResp);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__UpdateServerInfoResp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__UpdateServerInfoResp ** SOAP_FMAC4 soap_get_PointerTons2__UpdateServerInfoResp(struct soap *soap, struct ns2__UpdateServerInfoResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UpdateServerInfoResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__UpdateServerInfoResp ** SOAP_FMAC4 soap_in_PointerTons2__UpdateServerInfoResp(struct soap *soap, const char *tag, struct ns2__UpdateServerInfoResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__UpdateServerInfoResp **)soap_malloc(soap, sizeof(struct ns2__UpdateServerInfoResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__UpdateServerInfoResp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__UpdateServerInfoResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UpdateServerInfoResp, sizeof(struct ns2__UpdateServerInfoResp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__updateSysConfResponse(struct soap *soap, struct ns3__updateSysConfResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__updateSysConfResponse))
		soap_serialize_ns3__updateSysConfResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__updateSysConfResponse(struct soap *soap, struct ns3__updateSysConfResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__updateSysConfResponse);
	if (soap_out_PointerTons3__updateSysConfResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__updateSysConfResponse(struct soap *soap, const char *tag, int id, struct ns3__updateSysConfResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__updateSysConfResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__updateSysConfResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__updateSysConfResponse ** SOAP_FMAC4 soap_get_PointerTons3__updateSysConfResponse(struct soap *soap, struct ns3__updateSysConfResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__updateSysConfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__updateSysConfResponse ** SOAP_FMAC4 soap_in_PointerTons3__updateSysConfResponse(struct soap *soap, const char *tag, struct ns3__updateSysConfResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__updateSysConfResponse **)soap_malloc(soap, sizeof(struct ns3__updateSysConfResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__updateSysConfResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__updateSysConfResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__updateSysConfResponse, sizeof(struct ns3__updateSysConfResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UpdateSysConfReq(struct soap *soap, struct ns2__UpdateSysConfReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UpdateSysConfReq))
		soap_serialize_ns2__UpdateSysConfReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UpdateSysConfReq(struct soap *soap, struct ns2__UpdateSysConfReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UpdateSysConfReq);
	if (soap_out_PointerTons2__UpdateSysConfReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UpdateSysConfReq(struct soap *soap, const char *tag, int id, struct ns2__UpdateSysConfReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UpdateSysConfReq);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__UpdateSysConfReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__UpdateSysConfReq ** SOAP_FMAC4 soap_get_PointerTons2__UpdateSysConfReq(struct soap *soap, struct ns2__UpdateSysConfReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UpdateSysConfReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__UpdateSysConfReq ** SOAP_FMAC4 soap_in_PointerTons2__UpdateSysConfReq(struct soap *soap, const char *tag, struct ns2__UpdateSysConfReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__UpdateSysConfReq **)soap_malloc(soap, sizeof(struct ns2__UpdateSysConfReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__UpdateSysConfReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__UpdateSysConfReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UpdateSysConfReq, sizeof(struct ns2__UpdateSysConfReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UpdateSysConfResp(struct soap *soap, struct ns2__UpdateSysConfResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UpdateSysConfResp))
		soap_serialize_ns2__UpdateSysConfResp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UpdateSysConfResp(struct soap *soap, struct ns2__UpdateSysConfResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UpdateSysConfResp);
	if (soap_out_PointerTons2__UpdateSysConfResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UpdateSysConfResp(struct soap *soap, const char *tag, int id, struct ns2__UpdateSysConfResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UpdateSysConfResp);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__UpdateSysConfResp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__UpdateSysConfResp ** SOAP_FMAC4 soap_get_PointerTons2__UpdateSysConfResp(struct soap *soap, struct ns2__UpdateSysConfResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UpdateSysConfResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__UpdateSysConfResp ** SOAP_FMAC4 soap_in_PointerTons2__UpdateSysConfResp(struct soap *soap, const char *tag, struct ns2__UpdateSysConfResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__UpdateSysConfResp **)soap_malloc(soap, sizeof(struct ns2__UpdateSysConfResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__UpdateSysConfResp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__UpdateSysConfResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UpdateSysConfResp, sizeof(struct ns2__UpdateSysConfResp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__setMileageResponse(struct soap *soap, struct ns3__setMileageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__setMileageResponse))
		soap_serialize_ns3__setMileageResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__setMileageResponse(struct soap *soap, struct ns3__setMileageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__setMileageResponse);
	if (soap_out_PointerTons3__setMileageResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__setMileageResponse(struct soap *soap, const char *tag, int id, struct ns3__setMileageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__setMileageResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__setMileageResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__setMileageResponse ** SOAP_FMAC4 soap_get_PointerTons3__setMileageResponse(struct soap *soap, struct ns3__setMileageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__setMileageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__setMileageResponse ** SOAP_FMAC4 soap_in_PointerTons3__setMileageResponse(struct soap *soap, const char *tag, struct ns3__setMileageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__setMileageResponse **)soap_malloc(soap, sizeof(struct ns3__setMileageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__setMileageResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__setMileageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__setMileageResponse, sizeof(struct ns3__setMileageResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SetMileageReq(struct soap *soap, struct ns2__SetMileageReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SetMileageReq))
		soap_serialize_ns2__SetMileageReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SetMileageReq(struct soap *soap, struct ns2__SetMileageReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SetMileageReq);
	if (soap_out_PointerTons2__SetMileageReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SetMileageReq(struct soap *soap, const char *tag, int id, struct ns2__SetMileageReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SetMileageReq);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SetMileageReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SetMileageReq ** SOAP_FMAC4 soap_get_PointerTons2__SetMileageReq(struct soap *soap, struct ns2__SetMileageReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SetMileageReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SetMileageReq ** SOAP_FMAC4 soap_in_PointerTons2__SetMileageReq(struct soap *soap, const char *tag, struct ns2__SetMileageReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SetMileageReq **)soap_malloc(soap, sizeof(struct ns2__SetMileageReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SetMileageReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SetMileageReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SetMileageReq, sizeof(struct ns2__SetMileageReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SetMileageResp(struct soap *soap, struct ns2__SetMileageResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SetMileageResp))
		soap_serialize_ns2__SetMileageResp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SetMileageResp(struct soap *soap, struct ns2__SetMileageResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SetMileageResp);
	if (soap_out_PointerTons2__SetMileageResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SetMileageResp(struct soap *soap, const char *tag, int id, struct ns2__SetMileageResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SetMileageResp);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SetMileageResp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SetMileageResp ** SOAP_FMAC4 soap_get_PointerTons2__SetMileageResp(struct soap *soap, struct ns2__SetMileageResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SetMileageResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SetMileageResp ** SOAP_FMAC4 soap_in_PointerTons2__SetMileageResp(struct soap *soap, const char *tag, struct ns2__SetMileageResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SetMileageResp **)soap_malloc(soap, sizeof(struct ns2__SetMileageResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SetMileageResp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SetMileageResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SetMileageResp, sizeof(struct ns2__SetMileageResp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__setGPSFrequencyResponse(struct soap *soap, struct ns3__setGPSFrequencyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__setGPSFrequencyResponse))
		soap_serialize_ns3__setGPSFrequencyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__setGPSFrequencyResponse(struct soap *soap, struct ns3__setGPSFrequencyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__setGPSFrequencyResponse);
	if (soap_out_PointerTons3__setGPSFrequencyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__setGPSFrequencyResponse(struct soap *soap, const char *tag, int id, struct ns3__setGPSFrequencyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__setGPSFrequencyResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__setGPSFrequencyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__setGPSFrequencyResponse ** SOAP_FMAC4 soap_get_PointerTons3__setGPSFrequencyResponse(struct soap *soap, struct ns3__setGPSFrequencyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__setGPSFrequencyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__setGPSFrequencyResponse ** SOAP_FMAC4 soap_in_PointerTons3__setGPSFrequencyResponse(struct soap *soap, const char *tag, struct ns3__setGPSFrequencyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__setGPSFrequencyResponse **)soap_malloc(soap, sizeof(struct ns3__setGPSFrequencyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__setGPSFrequencyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__setGPSFrequencyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__setGPSFrequencyResponse, sizeof(struct ns3__setGPSFrequencyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SetGPSFrequencyReq(struct soap *soap, struct ns2__SetGPSFrequencyReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SetGPSFrequencyReq))
		soap_serialize_ns2__SetGPSFrequencyReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SetGPSFrequencyReq(struct soap *soap, struct ns2__SetGPSFrequencyReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SetGPSFrequencyReq);
	if (soap_out_PointerTons2__SetGPSFrequencyReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SetGPSFrequencyReq(struct soap *soap, const char *tag, int id, struct ns2__SetGPSFrequencyReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SetGPSFrequencyReq);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SetGPSFrequencyReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SetGPSFrequencyReq ** SOAP_FMAC4 soap_get_PointerTons2__SetGPSFrequencyReq(struct soap *soap, struct ns2__SetGPSFrequencyReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SetGPSFrequencyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SetGPSFrequencyReq ** SOAP_FMAC4 soap_in_PointerTons2__SetGPSFrequencyReq(struct soap *soap, const char *tag, struct ns2__SetGPSFrequencyReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SetGPSFrequencyReq **)soap_malloc(soap, sizeof(struct ns2__SetGPSFrequencyReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SetGPSFrequencyReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SetGPSFrequencyReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SetGPSFrequencyReq, sizeof(struct ns2__SetGPSFrequencyReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SetGPSFrequencyResp(struct soap *soap, struct ns2__SetGPSFrequencyResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SetGPSFrequencyResp))
		soap_serialize_ns2__SetGPSFrequencyResp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SetGPSFrequencyResp(struct soap *soap, struct ns2__SetGPSFrequencyResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SetGPSFrequencyResp);
	if (soap_out_PointerTons2__SetGPSFrequencyResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SetGPSFrequencyResp(struct soap *soap, const char *tag, int id, struct ns2__SetGPSFrequencyResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SetGPSFrequencyResp);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SetGPSFrequencyResp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SetGPSFrequencyResp ** SOAP_FMAC4 soap_get_PointerTons2__SetGPSFrequencyResp(struct soap *soap, struct ns2__SetGPSFrequencyResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SetGPSFrequencyResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SetGPSFrequencyResp ** SOAP_FMAC4 soap_in_PointerTons2__SetGPSFrequencyResp(struct soap *soap, const char *tag, struct ns2__SetGPSFrequencyResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SetGPSFrequencyResp **)soap_malloc(soap, sizeof(struct ns2__SetGPSFrequencyResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SetGPSFrequencyResp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SetGPSFrequencyResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SetGPSFrequencyResp, sizeof(struct ns2__SetGPSFrequencyResp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__sendMessageResponse(struct soap *soap, struct ns3__sendMessageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__sendMessageResponse))
		soap_serialize_ns3__sendMessageResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__sendMessageResponse(struct soap *soap, struct ns3__sendMessageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__sendMessageResponse);
	if (soap_out_PointerTons3__sendMessageResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__sendMessageResponse(struct soap *soap, const char *tag, int id, struct ns3__sendMessageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__sendMessageResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__sendMessageResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__sendMessageResponse ** SOAP_FMAC4 soap_get_PointerTons3__sendMessageResponse(struct soap *soap, struct ns3__sendMessageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__sendMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__sendMessageResponse ** SOAP_FMAC4 soap_in_PointerTons3__sendMessageResponse(struct soap *soap, const char *tag, struct ns3__sendMessageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__sendMessageResponse **)soap_malloc(soap, sizeof(struct ns3__sendMessageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__sendMessageResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__sendMessageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__sendMessageResponse, sizeof(struct ns3__sendMessageResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SendMsgReq(struct soap *soap, struct ns2__SendMsgReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SendMsgReq))
		soap_serialize_ns2__SendMsgReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SendMsgReq(struct soap *soap, struct ns2__SendMsgReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SendMsgReq);
	if (soap_out_PointerTons2__SendMsgReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SendMsgReq(struct soap *soap, const char *tag, int id, struct ns2__SendMsgReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SendMsgReq);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SendMsgReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SendMsgReq ** SOAP_FMAC4 soap_get_PointerTons2__SendMsgReq(struct soap *soap, struct ns2__SendMsgReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SendMsgReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SendMsgReq ** SOAP_FMAC4 soap_in_PointerTons2__SendMsgReq(struct soap *soap, const char *tag, struct ns2__SendMsgReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SendMsgReq **)soap_malloc(soap, sizeof(struct ns2__SendMsgReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SendMsgReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SendMsgReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SendMsgReq, sizeof(struct ns2__SendMsgReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SendMsgResp(struct soap *soap, struct ns2__SendMsgResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SendMsgResp))
		soap_serialize_ns2__SendMsgResp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SendMsgResp(struct soap *soap, struct ns2__SendMsgResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SendMsgResp);
	if (soap_out_PointerTons2__SendMsgResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SendMsgResp(struct soap *soap, const char *tag, int id, struct ns2__SendMsgResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SendMsgResp);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SendMsgResp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SendMsgResp ** SOAP_FMAC4 soap_get_PointerTons2__SendMsgResp(struct soap *soap, struct ns2__SendMsgResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SendMsgResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__SendMsgResp ** SOAP_FMAC4 soap_in_PointerTons2__SendMsgResp(struct soap *soap, const char *tag, struct ns2__SendMsgResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SendMsgResp **)soap_malloc(soap, sizeof(struct ns2__SendMsgResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SendMsgResp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SendMsgResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SendMsgResp, sizeof(struct ns2__SendMsgResp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__queryVersionResponse(struct soap *soap, struct ns3__queryVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__queryVersionResponse))
		soap_serialize_ns3__queryVersionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__queryVersionResponse(struct soap *soap, struct ns3__queryVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__queryVersionResponse);
	if (soap_out_PointerTons3__queryVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__queryVersionResponse(struct soap *soap, const char *tag, int id, struct ns3__queryVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__queryVersionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__queryVersionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__queryVersionResponse ** SOAP_FMAC4 soap_get_PointerTons3__queryVersionResponse(struct soap *soap, struct ns3__queryVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__queryVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__queryVersionResponse ** SOAP_FMAC4 soap_in_PointerTons3__queryVersionResponse(struct soap *soap, const char *tag, struct ns3__queryVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__queryVersionResponse **)soap_malloc(soap, sizeof(struct ns3__queryVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__queryVersionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__queryVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__queryVersionResponse, sizeof(struct ns3__queryVersionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__QueryVerReq(struct soap *soap, struct ns2__QueryVerReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__QueryVerReq))
		soap_serialize_ns2__QueryVerReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__QueryVerReq(struct soap *soap, struct ns2__QueryVerReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__QueryVerReq);
	if (soap_out_PointerTons2__QueryVerReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__QueryVerReq(struct soap *soap, const char *tag, int id, struct ns2__QueryVerReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__QueryVerReq);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__QueryVerReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__QueryVerReq ** SOAP_FMAC4 soap_get_PointerTons2__QueryVerReq(struct soap *soap, struct ns2__QueryVerReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__QueryVerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__QueryVerReq ** SOAP_FMAC4 soap_in_PointerTons2__QueryVerReq(struct soap *soap, const char *tag, struct ns2__QueryVerReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__QueryVerReq **)soap_malloc(soap, sizeof(struct ns2__QueryVerReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__QueryVerReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__QueryVerReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__QueryVerReq, sizeof(struct ns2__QueryVerReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__QueryVerResp(struct soap *soap, struct ns2__QueryVerResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__QueryVerResp))
		soap_serialize_ns2__QueryVerResp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__QueryVerResp(struct soap *soap, struct ns2__QueryVerResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__QueryVerResp);
	if (soap_out_PointerTons2__QueryVerResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__QueryVerResp(struct soap *soap, const char *tag, int id, struct ns2__QueryVerResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__QueryVerResp);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__QueryVerResp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__QueryVerResp ** SOAP_FMAC4 soap_get_PointerTons2__QueryVerResp(struct soap *soap, struct ns2__QueryVerResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__QueryVerResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__QueryVerResp ** SOAP_FMAC4 soap_in_PointerTons2__QueryVerResp(struct soap *soap, const char *tag, struct ns2__QueryVerResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__QueryVerResp **)soap_malloc(soap, sizeof(struct ns2__QueryVerResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__QueryVerResp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__QueryVerResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__QueryVerResp, sizeof(struct ns2__QueryVerResp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__takePhotoResponse(struct soap *soap, struct ns3__takePhotoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__takePhotoResponse))
		soap_serialize_ns3__takePhotoResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__takePhotoResponse(struct soap *soap, struct ns3__takePhotoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__takePhotoResponse);
	if (soap_out_PointerTons3__takePhotoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__takePhotoResponse(struct soap *soap, const char *tag, int id, struct ns3__takePhotoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__takePhotoResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__takePhotoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__takePhotoResponse ** SOAP_FMAC4 soap_get_PointerTons3__takePhotoResponse(struct soap *soap, struct ns3__takePhotoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__takePhotoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns3__takePhotoResponse ** SOAP_FMAC4 soap_in_PointerTons3__takePhotoResponse(struct soap *soap, const char *tag, struct ns3__takePhotoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__takePhotoResponse **)soap_malloc(soap, sizeof(struct ns3__takePhotoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__takePhotoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__takePhotoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__takePhotoResponse, sizeof(struct ns3__takePhotoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TakePhotoReq(struct soap *soap, struct ns2__TakePhotoReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TakePhotoReq))
		soap_serialize_ns2__TakePhotoReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TakePhotoReq(struct soap *soap, struct ns2__TakePhotoReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TakePhotoReq);
	if (soap_out_PointerTons2__TakePhotoReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TakePhotoReq(struct soap *soap, const char *tag, int id, struct ns2__TakePhotoReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TakePhotoReq);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__TakePhotoReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__TakePhotoReq ** SOAP_FMAC4 soap_get_PointerTons2__TakePhotoReq(struct soap *soap, struct ns2__TakePhotoReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TakePhotoReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__TakePhotoReq ** SOAP_FMAC4 soap_in_PointerTons2__TakePhotoReq(struct soap *soap, const char *tag, struct ns2__TakePhotoReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__TakePhotoReq **)soap_malloc(soap, sizeof(struct ns2__TakePhotoReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__TakePhotoReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__TakePhotoReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TakePhotoReq, sizeof(struct ns2__TakePhotoReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TakePhotoResp(struct soap *soap, struct ns2__TakePhotoResp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TakePhotoResp))
		soap_serialize_ns2__TakePhotoResp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TakePhotoResp(struct soap *soap, struct ns2__TakePhotoResp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TakePhotoResp);
	if (soap_out_PointerTons2__TakePhotoResp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TakePhotoResp(struct soap *soap, const char *tag, int id, struct ns2__TakePhotoResp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TakePhotoResp);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__TakePhotoResp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__TakePhotoResp ** SOAP_FMAC4 soap_get_PointerTons2__TakePhotoResp(struct soap *soap, struct ns2__TakePhotoResp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TakePhotoResp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns2__TakePhotoResp ** SOAP_FMAC4 soap_in_PointerTons2__TakePhotoResp(struct soap *soap, const char *tag, struct ns2__TakePhotoResp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__TakePhotoResp **)soap_malloc(soap, sizeof(struct ns2__TakePhotoResp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__TakePhotoResp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__TakePhotoResp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TakePhotoResp, sizeof(struct ns2__TakePhotoResp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__sayHelloResponse(struct soap *soap, struct _ns1__sayHelloResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__sayHelloResponse))
		soap_serialize__ns1__sayHelloResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__sayHelloResponse(struct soap *soap, struct _ns1__sayHelloResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__sayHelloResponse);
	if (soap_out_PointerTo_ns1__sayHelloResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__sayHelloResponse(struct soap *soap, const char *tag, int id, struct _ns1__sayHelloResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__sayHelloResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__sayHelloResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__sayHelloResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__sayHelloResponse(struct soap *soap, struct _ns1__sayHelloResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__sayHelloResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__sayHelloResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__sayHelloResponse(struct soap *soap, const char *tag, struct _ns1__sayHelloResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__sayHelloResponse **)soap_malloc(soap, sizeof(struct _ns1__sayHelloResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__sayHelloResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__sayHelloResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__sayHelloResponse, sizeof(struct _ns1__sayHelloResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__sayHello(struct soap *soap, struct _ns1__sayHello *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__sayHello))
		soap_serialize__ns1__sayHello(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__sayHello(struct soap *soap, struct _ns1__sayHello *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__sayHello);
	if (soap_out_PointerTo_ns1__sayHello(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__sayHello(struct soap *soap, const char *tag, int id, struct _ns1__sayHello *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__sayHello);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__sayHello(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__sayHello ** SOAP_FMAC4 soap_get_PointerTo_ns1__sayHello(struct soap *soap, struct _ns1__sayHello **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__sayHello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__sayHello ** SOAP_FMAC4 soap_in_PointerTo_ns1__sayHello(struct soap *soap, const char *tag, struct _ns1__sayHello **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__sayHello **)soap_malloc(soap, sizeof(struct _ns1__sayHello *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__sayHello(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__sayHello **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__sayHello, sizeof(struct _ns1__sayHello), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OperationCenterResponse(struct soap *soap, struct _ns1__OperationCenterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OperationCenterResponse))
		soap_serialize__ns1__OperationCenterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OperationCenterResponse(struct soap *soap, struct _ns1__OperationCenterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__OperationCenterResponse);
	if (soap_out_PointerTo_ns1__OperationCenterResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OperationCenterResponse(struct soap *soap, const char *tag, int id, struct _ns1__OperationCenterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OperationCenterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__OperationCenterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__OperationCenterResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__OperationCenterResponse(struct soap *soap, struct _ns1__OperationCenterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OperationCenterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__OperationCenterResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__OperationCenterResponse(struct soap *soap, const char *tag, struct _ns1__OperationCenterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__OperationCenterResponse **)soap_malloc(soap, sizeof(struct _ns1__OperationCenterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__OperationCenterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__OperationCenterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OperationCenterResponse, sizeof(struct _ns1__OperationCenterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OperationCenter(struct soap *soap, struct _ns1__OperationCenter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OperationCenter))
		soap_serialize__ns1__OperationCenter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OperationCenter(struct soap *soap, struct _ns1__OperationCenter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__OperationCenter);
	if (soap_out_PointerTo_ns1__OperationCenter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OperationCenter(struct soap *soap, const char *tag, int id, struct _ns1__OperationCenter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OperationCenter);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__OperationCenter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__OperationCenter ** SOAP_FMAC4 soap_get_PointerTo_ns1__OperationCenter(struct soap *soap, struct _ns1__OperationCenter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OperationCenter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__OperationCenter ** SOAP_FMAC4 soap_in_PointerTo_ns1__OperationCenter(struct soap *soap, const char *tag, struct _ns1__OperationCenter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__OperationCenter **)soap_malloc(soap, sizeof(struct _ns1__OperationCenter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__OperationCenter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__OperationCenter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OperationCenter, sizeof(struct _ns1__OperationCenter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OperationSmsResponse(struct soap *soap, struct _ns1__OperationSmsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OperationSmsResponse))
		soap_serialize__ns1__OperationSmsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OperationSmsResponse(struct soap *soap, struct _ns1__OperationSmsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__OperationSmsResponse);
	if (soap_out_PointerTo_ns1__OperationSmsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OperationSmsResponse(struct soap *soap, const char *tag, int id, struct _ns1__OperationSmsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OperationSmsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__OperationSmsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__OperationSmsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__OperationSmsResponse(struct soap *soap, struct _ns1__OperationSmsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OperationSmsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__OperationSmsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__OperationSmsResponse(struct soap *soap, const char *tag, struct _ns1__OperationSmsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__OperationSmsResponse **)soap_malloc(soap, sizeof(struct _ns1__OperationSmsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__OperationSmsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__OperationSmsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OperationSmsResponse, sizeof(struct _ns1__OperationSmsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OperationSms(struct soap *soap, struct _ns1__OperationSms *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OperationSms))
		soap_serialize__ns1__OperationSms(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OperationSms(struct soap *soap, struct _ns1__OperationSms *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__OperationSms);
	if (soap_out_PointerTo_ns1__OperationSms(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OperationSms(struct soap *soap, const char *tag, int id, struct _ns1__OperationSms *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OperationSms);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__OperationSms(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__OperationSms ** SOAP_FMAC4 soap_get_PointerTo_ns1__OperationSms(struct soap *soap, struct _ns1__OperationSms **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OperationSms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _ns1__OperationSms ** SOAP_FMAC4 soap_in_PointerTo_ns1__OperationSms(struct soap *soap, const char *tag, struct _ns1__OperationSms **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__OperationSms **)soap_malloc(soap, sizeof(struct _ns1__OperationSms *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__OperationSms(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__OperationSms **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OperationSms, sizeof(struct _ns1__OperationSms), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

#ifdef __cplusplus
}
#endif

/* End of soapC.c */
